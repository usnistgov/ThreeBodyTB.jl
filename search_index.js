var documenterSearchIndex = {"docs":
[{"location":"every/#ThreeBodyTB","page":"Additional Docstrings","title":"ThreeBodyTB","text":"","category":"section"},{"location":"every/#TB","page":"Additional Docstrings","title":"TB","text":"","category":"section"},{"location":"every/","page":"Additional Docstrings","title":"Additional Docstrings","text":"ThreeBodyTB.TB.tb_k\nThreeBodyTB.TB.tb_crys_kspace\nThreeBodyTB.TB.read_tb_crys_kspace\nThreeBodyTB.TB.write_tb_crys_kspace\nThreeBodyTB.TB.make_tb_crys\nThreeBodyTB.TB.make_tb_crys_kspace\nThreeBodyTB.TB.make_tb\nThreeBodyTB.TB.make_tb_k\nThreeBodyTB.TB.load_hr_dat\nThreeBodyTB.TB.calc_energy_fft\nThreeBodyTB.TB.calc_energy_charge_fft\nThreeBodyTB.TB.calc_energy\nThreeBodyTB.TB.types_energy\nThreeBodyTB.TB.make_kgrid\nThreeBodyTB.TB.trim\nThreeBodyTB.TB.organizedata\nThreeBodyTB.TB.myfft_R_to_K\nThreeBodyTB.TB.myfft\nThreeBodyTB.TB.get_sym_R\nThreeBodyTB.TB.tb_indexes\nThreeBodyTB.TB.find_vbm_cbm\nThreeBodyTB.TB.ewald_energy\nThreeBodyTB.TB.get_dq\nThreeBodyTB.TB.get_energy_electron_density_kspace\nset_bin_dirs","category":"page"},{"location":"every/#ThreeBodyTB.TB.tb_k","page":"Additional Docstrings","title":"ThreeBodyTB.TB.tb_k","text":"mutable struct tb_k{T}\n\nTight binding object in k-space. Can be from direct import of DFT band structure using atomic proj, or from fft'ed tb object. Similar to real-space version.\n\nHolds\n\nHk::Array{Complex{T},3} Hamiltonian in k-space\nK::Array{Float64,2} K point array. In fractional coordinates of BZ.\nkweights::Array{Float64,1} K point weights.\nk_dict::Dict Dictionary from k-point like [0,0,0] to index.\nnwan::Int64 Number of orbitals / generalized wannier functions.\nnk::Int64 Number of k-points.\nnonorth::Bool \nSk::Array{Complex{T},3} Overlap matrix.\nscf::Bool needs self-consistency?\nh1::Array{T,2} #scf term holds scf term if present\ngrid::Array{Int64,1} dimensions of k-point grid, from regular grid like [8,8,8]\n\n\n\n\n\n","category":"type"},{"location":"every/#ThreeBodyTB.TB.tb_crys_kspace","page":"Additional Docstrings","title":"ThreeBodyTB.TB.tb_crys_kspace","text":"mutable struct tbcryskspace{T}\n\nHold k-point tight binding and crystal structure. Similar to tb_crys\n\nHolds\n\ntb::tb_k\ncrys::crystal\nnelec::Float64\ndftenergy::Float64\nscf::Bool\ngamma::Array{T, 2}\neden::Array{Float64,1}\n\n\n\n\n\n","category":"type"},{"location":"every/#ThreeBodyTB.TB.read_tb_crys_kspace","page":"Additional Docstrings","title":"ThreeBodyTB.TB.read_tb_crys_kspace","text":"function read_tb_crys_kspace(filename; directory=missing)\n\nReads and returns from filename a tb_crys_kspace object. See write_tb_crys_kspace\n\nIf cannot find \"filename\", will look for \"filename.xml\", \"filename.gz\", \"filename.xml.gz\"\n\nCan read gzipped files directly.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.TB.write_tb_crys_kspace","page":"Additional Docstrings","title":"ThreeBodyTB.TB.write_tb_crys_kspace","text":"function write_tb_crys_kspace(filename, tbc::tb_crys_kspace)\n\nSave a tb_crys_kspace object to xml format. See read_tb_crys_kspace\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.TB.make_tb_crys","page":"Additional Docstrings","title":"ThreeBodyTB.TB.make_tb_crys","text":"function make_tb_crys(ham::tb,crys::crystal, nelec::Float64, dftenergy::Float64; scf=false, eden = missing, gamma=missing, within_fit=true, screening=1.0, tb_energy=-999, fermi_energy=0.0 )\n\nConstructor function for tb_crys object\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.TB.make_tb_crys_kspace","page":"Additional Docstrings","title":"ThreeBodyTB.TB.make_tb_crys_kspace","text":"function make_tb_crys_kspace(hamk::tb_k,crys::crystal, nelec::Float64, dftenergy::Float64; scf=false, eden = missing, gamma=missing, screening=1.0)\n\nConstructor function for tb_crys_kspace object\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.TB.make_tb","page":"Additional Docstrings","title":"ThreeBodyTB.TB.make_tb","text":"function make_tb(H, ind_arr, r_dict::Dict; h1=missing)\n\nConstructor function for tb\n\n\n\n\n\nfunction make_tb(H, ind_arr, r_dict::Dict, S; h1=missing)\n\nConstructor function for tb with overlaps\n\n\n\n\n\nfunction make_tb(H, ind_arr, S; h1=missing)\n\nConstructor function for tb, better programming.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.TB.make_tb_k","page":"Additional Docstrings","title":"ThreeBodyTB.TB.make_tb_k","text":"function make_tb_k(Hk, K, kweights, Sk; h1=missing, grid=[0,0,0], nonorth=true)\n\nConstructor for tb_kspace\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.TB.load_hr_dat","page":"Additional Docstrings","title":"ThreeBodyTB.TB.load_hr_dat","text":"function load_hr_dat(filename, directory=\"\")\n\nLoad a wannier90 hr.dat file Not currently a major part of program, but you can use if you want.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.TB.calc_energy_fft","page":"Additional Docstrings","title":"ThreeBodyTB.TB.calc_energy_fft","text":"function calc_energy_fft(tbc::tb_crys; grid=missing, smearing=0.01, return_more_info=false)\n\nGet energy using fft.\n\nreturns energy\n\nif return_more_info==true then returns etot, efermi, vals, vects\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.TB.calc_energy_charge_fft","page":"Additional Docstrings","title":"ThreeBodyTB.TB.calc_energy_charge_fft","text":"function calc_energy_charge_fft(tbc::tb_crys; grid=missing, smearing=0.01)\n\nDo fft, then calculate energy and charge.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.TB.calc_energy","page":"Additional Docstrings","title":"ThreeBodyTB.TB.calc_energy","text":"function calc_energy(tbc::tb_crys; smearing=0.01, returnk=false)\n\nCalculate energy without fft.\n\n\n\n\n\nfunction calc_energy(h::tb_crys, kgrid; smearing=0.01, returnk=false)\n\nCalculate energy no fft\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.TB.types_energy","page":"Additional Docstrings","title":"ThreeBodyTB.TB.types_energy","text":"function types_energy(tbc::tb_crys)\n\nCalculate the reference energy of each atom in crystal. This results in the  total energy being indexed to seperated non-spin-polarized atoms. This is arbirary.\n\n\n\n\n\nfunction types_energy(tbc::tb_crys)\n\n\n\n\n\nfunction types_energy(c::crystal)\n\n\n\n\n\nfunction types_energy(types)\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.TB.make_kgrid","page":"Additional Docstrings","title":"ThreeBodyTB.TB.make_kgrid","text":"function make_kgrid(kgrid)\n\n-kgrid is an array of 3 integers like [8,8,8] \n\nreturns regular MP Gamma-centered k-point grid and (equal) k-weights.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.TB.trim","page":"Additional Docstrings","title":"ThreeBodyTB.TB.trim","text":"function trim(h::tb, tol=0.0002)\n\nRemove terms in tb with abs value smaller than tol. (Ryd) Will speed calculations at cost of accuracy. USE WITH CARE. Usually not necessary except for very large or very detailed calculations.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.TB.organizedata","page":"Additional Docstrings","title":"ThreeBodyTB.TB.organizedata","text":"function organizedata(tbc::tb_crys)\n\nRearrange the data in the tbc as a function of distances for plotting purposes.\n\nreturn data_onsite, data_arr\n\nReturns two arrays. The first has data on the onsite elements.\n\ncolumn 1 and 3 have atom indexes\ncolumn 2 and 4 have orbital numbers\ncolumns 5 and 6 have real and imaginary parts of H\ncolumns 11 and 12 have real and imaginary parts of S\ncolumn 7 has the closest inter-atomic distance\ncolumn 8 has the index of the closest atom.\n\nThe second has intersite data\n\ncolumn 1 and 3 have atom indexes for the atom pairs\ncolumn 2 and 4 have orbital numbers\ncolumns 5 and 6 have real and imaginary parts of H\ncolumns 11 and 12 have real and imaginary parts of S\ncolumn 7 has the inter-atomic distance\ncolumn 8,9,10 have the the direction cosines lmn for the atom pair.\n\n\n\n\n\nfunction organizedata(crys::crystal, h::tb)\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.TB.myfft_R_to_K","page":"Additional Docstrings","title":"ThreeBodyTB.TB.myfft_R_to_K","text":"function myfft_R_to_K(tbc, grid=missing)\n\nDoes Fourier Transform R->k (fft) using FFTW for tb_crys\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.TB.myfft","page":"Additional Docstrings","title":"ThreeBodyTB.TB.myfft","text":"function myfft(crys, nonorth, grid, kpts,ham_kS, Sk=missing)\n\nDoes Fourier Transform K->R (ifft) using FFTW.\n\nArguments\n\ncrys crystal\nnonorth nonorogonal bool\ngrid k-point grid size\nkpts the k-points nkpts×3 in the original order, to be rearranged into grid\nham_kS hamiltonian in k space (nw×nw×nkpts)\nSk overlaps in k space\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.TB.get_sym_R","page":"Additional Docstrings","title":"ThreeBodyTB.TB.get_sym_R","text":"function get_sym_R(crys, grid, sss = 1.0)\n\nFigures out the r-space grid using Wigner-Seitz like construction to figure out the best arrangement of r-grid points to keep periodic copies closest to the original atom  and take into account symmetry.\n\nreturn R_grid, R_int_grid, sym_R\n\nreturns the R_grid, the integer version, and the symmetry factor of each point.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.TB.tb_indexes","page":"Additional Docstrings","title":"ThreeBodyTB.TB.tb_indexes","text":"function tb_indexes(d::dftout)\n\nFigures out mapping between DFT projected hamiltonian orbitals and crystal and the wannier orbitals we want.\n\nreturn wan, semicore, nwan, nsemi, wan_atom, atom_wan\n\nwan has the indexes of the wannier orbitals\nsemicore has the indexes of semicore states.\nnwan number of wannier orbs\nnsemi number of semicore states\nwan_atom dictionary wannier to atom numbers\natom_wan dictionary atom numbers to wannier orbitals\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.TB.find_vbm_cbm","page":"Additional Docstrings","title":"ThreeBodyTB.TB.find_vbm_cbm","text":"function find_vbm_cbm(eigs, fermi)\n\nFind the valence band max and conduction band minimum from eigs, relative to Fermi level.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.TB.ewald_energy","page":"Additional Docstrings","title":"ThreeBodyTB.TB.ewald_energy","text":"function ewald_energy(tbc::tb_crys, delta_q=missing)\n\nReturn ewald energy term from tbc. If delta_q, the atomic charge density, is missing, loads from tbc.\n\n\n\n\n\nfunction ewald_energy(tbc::tb_crys_kspace, delta_q=missing)\n\n\n\n\n\nfunction ewald_energy(crys::crystal, gamma, delta_q::Array{Float64,1})\n\nDoes the actual calculation.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.TB.get_dq","page":"Additional Docstrings","title":"ThreeBodyTB.TB.get_dq","text":"function get_dq(tbc::tb_crys_kspace)\n\nGet atomic charge density from tb_crys or tb_crys_kspace or crys + eden\n\n\n\n\n\nfunction get_dq(tbc::tb_crys)\n\n\n\n\n\nfunction get_dq(crys::crystal, chargeden::Array{Float64,1})\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.TB.get_energy_electron_density_kspace","page":"Additional Docstrings","title":"ThreeBodyTB.TB.get_energy_electron_density_kspace","text":"function get_energy_electron_density_kspace(tbcK::tb_crys_kspace; smearing = 0.01)\n\nGet energy / charge density from k-space tight binding object.\n\nreturn bandenergy + etypes + echarge + energy_smear, eden, VECTS, VALS, error_flag\n\n\n\n\n\nfunction get_energy_electron_density_kspace(tb_k::tb_k, nelec; smearing = 0.01)\n\nK-space get energy and electron density from tb_k\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.set_bin_dirs","page":"Additional Docstrings","title":"ThreeBodyTB.set_bin_dirs","text":"function set_bin_dirs(;qe=missing, mpi=missing, pseudodir=missing, templatedir=missing, wannier=missing)\n\nSet directories where things like quantum espresso bins are located. If run with everything missing, instead print current dirs.\n\nqe - set bin directory of quantum espresso. Needs pw and pp installed. No useful default.\nmpi - set mpi command. something like \"mpirun -np \"\npseudo - set directory for pseudopotentials. Default is to use ../pseudo/gbrv_pbesol/ as distributed with this code\ntemplate - set directory for quantum espresso template files. Uses ../template_inputs/ by default.\n\n\n\n\n\n","category":"function"},{"location":"every/#AtomicProj","page":"Additional Docstrings","title":"AtomicProj","text":"","category":"section"},{"location":"every/","page":"Additional Docstrings","title":"Additional Docstrings","text":"Modules = [ThreeBodyTB.AtomicProj]","category":"page"},{"location":"every/#ThreeBodyTB.AtomicProj","page":"Additional Docstrings","title":"ThreeBodyTB.AtomicProj","text":"module AtomicProj\n\nAnalyze projections from QE projwfc.x\n\n\n\n\n\n","category":"module"},{"location":"every/#ThreeBodyTB.AtomicProj.proj_dat","page":"Additional Docstrings","title":"ThreeBodyTB.AtomicProj.proj_dat","text":"mutable struct proj_dat\n\nHolds data from projwfc.x\n\nbs::bandstructure\nnatwfc::Int64 number of atomic wavefunctions, from dft projection\nproj::Array{Complex{Float64}, 3}  atomc projections nk × natwfc × nbnd , where nbnd is the number of bands in DFT\noverlaps::Array{Complex{Float64}, 3} overlap matrix from dftnk × natwfc × natwfc`\n\nThis is created from loadXML_proj, which calls make_proj\n\n\n\n\n\n","category":"type"},{"location":"every/#ThreeBodyTB.AtomicProj.create_tb-Tuple{ThreeBodyTB.AtomicProj.proj_dat, dftout}","page":"Additional Docstrings","title":"ThreeBodyTB.AtomicProj.create_tb","text":"function create_tb(p::proj_dat, d::dftout; energy_froz=missing, nfroz=0, shift_energy=true)\n\nDoes the main creation of TB hamiltonian from DFT projection data in k-space.\n\nArguments\n\np::proj_dat Projection data\nd::dftout DFT scf data\nenergy_froz=missing Energy to start freezing eigenvalues\nnfroz=0 number of frozen bands.\nshift_energy=true if true shift eigenvalues so band energy == total energy\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.AtomicProj.get_ham_r-Tuple{tb_crys_kspace}","page":"Additional Docstrings","title":"ThreeBodyTB.AtomicProj.get_ham_r","text":"function get_ham_r(tbck::tb_crys_kspace)\n\nDo fft to get the real-space ham. Requires tbck to be on a regular grid centered at Gamma with no symmetry.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.AtomicProj.get_ham_r_slow-Tuple{ThreeBodyTB.AtomicProj.proj_dat, dftout, Any, Array{ComplexF64, 3}}","page":"Additional Docstrings","title":"ThreeBodyTB.AtomicProj.get_ham_r_slow","text":"function get_ham_r_slow(p::proj_dat, d::dftout, grid, ham_k::Array{Complex{Float64}, 3}; nonorth=true, K=missing)\n\nSlow method for doing fourier transform. Uses standard ft formula, not fft.\n\nUse fast version instead.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.AtomicProj.loadXML_proj","page":"Additional Docstrings","title":"ThreeBodyTB.AtomicProj.loadXML_proj","text":"function loadXML_proj(savedir, B=missing)\n\nLoad proj from QE output file. Need the QE save dir like \"qe.save\". B are reciprocal lattice vectors.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.AtomicProj.makeOG-Tuple{Any, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.AtomicProj.makeOG","text":"function makeOG(prefix, tmpdir )\n\nopengrid.x inputfile. My workflow doesn't currently use this, as opengrid.x was unreliable, and I've rewritten the code to avoid it and work directly with independent k-points only.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.AtomicProj.make_commands","page":"Additional Docstrings","title":"ThreeBodyTB.AtomicProj.make_commands","text":"function make_commands(nprocs=1)\n\nReturns a dictionary with command lines to call external programs on the command line nprocs is the number of processors for parallel execution Needs to be changed for you specfic program locations  and mpi commands (if any)\n\nThis needs to be edited to actually run QE yourself. Running wannier90 is optional, not part of current code.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.AtomicProj.make_proj-Tuple{Any, Any, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.AtomicProj.make_proj","text":"function make_proj(bs, proj, overlaps)\n\nConstructor for proj_dat.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.AtomicProj.make_projwfcx-Tuple{Any, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.AtomicProj.make_projwfcx","text":"function make_projwfcx(prefix, tmpdir)\n\nCreate the inputfile for running projwfc.x from QE\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.AtomicProj.makedict_proj-Tuple{Any}","page":"Additional Docstrings","title":"ThreeBodyTB.AtomicProj.makedict_proj","text":"function makedict_proj(savedir)\n\nReturn xml proj data from QE savedir\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.AtomicProj.prepare_ham_k-Tuple{ThreeBodyTB.AtomicProj.proj_dat, dftout, Any, Array{ComplexF64, 3}}","page":"Additional Docstrings","title":"ThreeBodyTB.AtomicProj.prepare_ham_k","text":"function prepare_ham_k(p::proj_dat, d::dftout, grid, ham_k::Array{Complex{Float64}, 3}; nonorth=true, K=missing, localized_factor = 0.05, screening=1.0)\n\nConstructs the actual k-space hamiltonain, which involves lots of putting matricies in the correct form and de-orthogonalizing if desired.\n\n#arguments\n\np::proj_dat projection data\nd::dftout dft data\ngrid kpoint grid spacing \nham_k::Array{Complex{Float64}, 3} Hamiltonian\nnonorth=true make a non-orthogonal TB \nK=missing k-point array, usually get from p\nlocalized_factor = 0.15 increase localization of overlaps.\nscreening=1.0 mulitply U by this factor. usually not used.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.AtomicProj.projwfc_workf-Tuple{dftout}","page":"Additional Docstrings","title":"ThreeBodyTB.AtomicProj.projwfc_workf","text":"function projwfc_workf(dft::dftout)\n\nThis is the main workflow for the creation of TB matrix elements from QE DFT calculations.\n\nStarting from a converged QE scf calculation...\n\nRun NSCF calculation with extra empty bands. If you want a real space TB object, these need to be a full k-point grid not using symmtery. k-space only can use irreducible k-points\nRun projwfc.x\nConstruct the TB hamiltonian in k-space\n(Optional) FT to real space\n(Optional) cleanup wavefunctions.\n\nArguments\n\ndft::dftout The starting scf calculation\ndirectory=\"./\"\nnprocs=1 number of processors\nfreeze=true Keep occupied eigenvalues fixed to exact DFT values\nwritefile=\"projham.xml\" output file for real-space TB\nwritefilek=\"projham_K.xml\" output file for k-space TB\nskip_og=true  Not used anymore\nskip_proj=true If projections are already run, don't run them again, load from file.\nshift_energy=true Shift energy of eigenvalues s.t. total energy equal band energy.\ncleanup=true Remove the large wavefunction files from disk, keeping nscf/projection files.\nskip_nscf=true If nscf calculation is already done, load results from file.\nlocalized_factor = 0.15 Adjust extent of overlap matrix. 0.0 uses full atomic wavefunctions, which can be overly delocalized. 1.0 is fully localized.\nonly_kspace=false Do not create real-space tb. Usually true in current code, as I can fit directly from k-space tb only.\nscreening = 1.0 If use a screening factor to reduce value of U in Ewald calculation. Usually leave at 1.0.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.AtomicProj.run_og","page":"Additional Docstrings","title":"ThreeBodyTB.AtomicProj.run_og","text":"function run_og(filename=\"og.in\";  directory=\"./\", nprocs=1)\n\nruns open_grid.x\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.AtomicProj.run_projwfcx","page":"Additional Docstrings","title":"ThreeBodyTB.AtomicProj.run_projwfcx","text":"function run_projwfcx(projfile=\"proj.in\"; directory=\"./\", nprocs=1)\n\nRun projwfc.x from QE code\n\n\n\n\n\n","category":"function"},{"location":"every/#BandStruct","page":"Additional Docstrings","title":"BandStruct","text":"","category":"section"},{"location":"every/","page":"Additional Docstrings","title":"Additional Docstrings","text":"Modules = [ThreeBodyTB.BandStruct]","category":"page"},{"location":"every/#ThreeBodyTB.BandStruct.band_summary","page":"Additional Docstrings","title":"ThreeBodyTB.BandStruct.band_summary","text":"function band_summary(tbc, kgrid, fermi=missing)\n\nProduces summary of band structure. See below functions for more specific versions of function that automatically generate the k-points.\n\nNote: gaps are not well-defined for non-magnetic systems with odd numbers of electrons, as they are required to be metals.\n\nReturns direct_gap, indirect_gap, gaptype, bandwidth\n\n-direct_gap: minimum gap at one k-point between nominally filled and empty bands. Can be non-zero in metals.   -indirect_gap: LUMO - HOMO. Can be negative if material has a direct gap everywhere, but the conduction band at some k-point is below the valence band at a different k-point. Physically these are indirect gap semimetals.   -gaptype : is :metal for all metals, :direct or :indirect for insulators. -bandwidth : HOMO - minimumbandenergy. Included semicore states if they are in the TB calculation.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.BandStruct.band_summary-Tuple{tb_crys_kspace}","page":"Additional Docstrings","title":"ThreeBodyTB.BandStruct.band_summary","text":"function band_summary(tbc::tb_crys_kspace)\n\nWill use internal k-points by default.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.BandStruct.band_summary-Tuple{tb_crys}","page":"Additional Docstrings","title":"ThreeBodyTB.BandStruct.band_summary","text":"function band_summary(tbc::tb_crys; kgrid=missing, kpts=missing)\n\nWill automatically generate standard k-grid by default.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.BandStruct.get_kpath","page":"Additional Docstrings","title":"ThreeBodyTB.BandStruct.get_kpath","text":"function get_kpath(kpath=[0.5 0 0 ; 0 0 0; 0.5 0.5 0.5], names = missing, npts=30)\n\nConstruct a k_path for a band structure calculations. Very simple.\n\nkpath high symmetry k-points in fractional BZ coordinates.\nnames names of kpoints like [\"Γ\", \"X\"]\nnpts number of points between high-symmetry kpoints\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.BandStruct.plot_bandstr-Tuple{Any}","page":"Additional Docstrings","title":"ThreeBodyTB.BandStruct.plot_bandstr","text":"function plot_bandstr(h::tb)\n\nPlots using tb\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.BandStruct.plot_bandstr-Tuple{tb_crys}","page":"Additional Docstrings","title":"ThreeBodyTB.BandStruct.plot_bandstr","text":"function plot_bandstr(h::tb_crys; kpath, names = missing, proj_types=missing, proj_orbs = missing, proj_nums=missing)\n\nPlot the band structure of a tb_crys object. Can also perform a projected band structure if you specify at least one of proj_types, proj_orbs, proj_nums.\n\nk-path specified by a kpath array and names.\n\nMust do scf calculation before plotting.\n\nArguments\n\nh::tb_crys - The tight-biding object we want to plot bands from. Only required argument.\nkpath=[0.5 0 0 ; 0 0 0; 0.5 0.5 0.5; 0 0.5 0.5; 0 0 0 ;0 0 0.5] - nk × 3 array k-point path (high symmetry points).\nnpts=30, - number of points between high-symmetry k-points.\nnames=missing - nk string array. Names of the high-symmetry k-points \nproj_types=missing - types to project onto. Either proj_types=\"H\" or proj_types=[\"H\", \"O\"] are valid.\nproj_orbs=missing - orbitals to project onto. either proj_orbs=:s or proj_orbs=[:s, :p].\nproj_nums=missing - atom numbers to project onto. Either proj_nums=1 or proj_nums=[1, 2]\nefermi=missing - allows you to specify fermi energy. Default is to take from h\ncolor=\"blue\" - specify line color\nMarkerSize=missing\" - specify markersize\nyrange=missing\" - specify y-range. e.g. yrange=[-0.7, 0.3]\nplot_hk=false - plot things besides the normal band structure. Can be one of :Seig, :Heig, :Hreal, :Himag, :Sreal, :Simag to plot H or S eigvals or components. Primarily for debugging.\nalign=\"vbm\" - default or \"valence\" is to align valence band max to zero energy. Can also be \"min\", which aligns on the minimum eigenvalue, or \"fermi\" or \"ef\", which align on the Fermi level, \nclear_pervious=true - clears the plot before adding new stuff.\ndo_display=true - display the plot. If false, can be used with display-less nodes. You can still use savefig from Plots to produce saved images.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.BandStruct.plot_compare_dft-Tuple{Any, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.BandStruct.plot_compare_dft","text":"function plot_compare_dft(tbc, bs; tbc2=missing)\n\nPlots a band structure comparison between a tight-binding crystal object (tb_crys) and a band structure directly from dft (either a dftout or bs object). \n\nThe k-points are fixed by the bs object.\n\ntbc2 is an optional second tbc_crys.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.BandStruct.plot_compare_tb-Tuple{tb, tb}","page":"Additional Docstrings","title":"ThreeBodyTB.BandStruct.plot_compare_tb","text":"function plot_compare_tb(h1::tb, h2::tb; h3=missing)\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.BandStruct.plot_compare_tb-Tuple{tb_crys, tb_crys}","page":"Additional Docstrings","title":"ThreeBodyTB.BandStruct.plot_compare_tb","text":"function plot_compare_tb(h1::tb_crys, h2::tb_crys; h3=missing)\n\nPlot a comparison between different tight binding objects h1, h2, and optionally h3. Options similar to plot_bandstr but more limited.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.BandStruct.setup_proj-NTuple{5, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.BandStruct.setup_proj","text":"function setup_proj(crys, nwan, proj_types, proj_orbs, proj_nums)\n\nFigure out projection indexes\n\n\n\n\n\n","category":"method"},{"location":"every/#DOS","page":"Additional Docstrings","title":"DOS","text":"","category":"section"},{"location":"every/","page":"Additional Docstrings","title":"Additional Docstrings","text":"Modules = [ThreeBodyTB.DOS]","category":"page"},{"location":"every/#ThreeBodyTB.DOS.dos-Tuple{tb_crys}","page":"Additional Docstrings","title":"ThreeBodyTB.DOS.dos","text":"function dos(tbc::tb_crys; grid=missing, npts=missing, proj_type=missing, do_display=true)\n\nDOS, using tetrahedral integration\n\ngrid is the k-point grid. Defaults to 1.6 times the default grid for energy integration.\nnpts is number of energies\nproj_type can be \"none\", \"atomic\", or \"orbital\". Defaults to atomic if more than one atom type.\ndo_display=false will suppress plotting\n\nreturn energies, dos, projected_dos, pdos_names\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.DOS.gaussian_dos-Tuple{tb_crys}","page":"Additional Docstrings","title":"ThreeBodyTB.DOS.gaussian_dos","text":"function gaussian_dos(tbc::tb_crys; grid=missing, smearing=0.02, npts=missing, proj_type=missing, do_display=true)\n\nSimple Gaussian DOS, mostly for testing.\n\nnpts is number of energies\nproj_type can be \"none\", \"atomic\", or \"orbital\"\ndo_display=false will suppress the actual plot\n\nThe combination of smearing and grid are important to get converged results.\n\nSee also dos\n\nreturn energies, dos, projected_dos, pdos_names\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.DOS.plot_dos-NTuple{4, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.DOS.plot_dos","text":"function plot_dos(energies, dos, pdos, names; filename=missing, do_display=true)\n\nDoes the actual DOS plotting, called by dos or gaussian_dos\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.DOS.projection-Tuple{tb_crys, Any, Any, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.DOS.projection","text":"function projection(tbc::tb_crys, vects, sk3, grid; ptype=missing)\n\nFigures out the projections. ptype can be :atomic or :orbs for atom projection or orbital projection (:s,:p,:d) Default is to choose :atomic except for elemental systems.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.DOS.setup_tetra-Tuple{Any}","page":"Additional Docstrings","title":"ThreeBodyTB.DOS.setup_tetra","text":"function setup_tetra(grid)\n\nSetup simple tetrahedron method based on tetra.f90 in QE. Simple tetra method.\n\n\n\n\n\n","category":"method"},{"location":"every/#Atomdata","page":"Additional Docstrings","title":"Atomdata","text":"","category":"section"},{"location":"every/","page":"Additional Docstrings","title":"Additional Docstrings","text":"Modules = [ThreeBodyTB.Atomdata]","category":"page"},{"location":"every/#ThreeBodyTB.Atomdata","page":"Additional Docstrings","title":"ThreeBodyTB.Atomdata","text":"module Atomdata\n\nHolds the data for isolated atoms.\n\n\n\n\n\n","category":"module"},{"location":"every/#ThreeBodyTB.Atomdata.atom_prefered_oxidation","page":"Additional Docstrings","title":"ThreeBodyTB.Atomdata.atom_prefered_oxidation","text":"atom_prefered_oxidation::Dict()\n\nPrefered oxidation states of atoms, in descending order of preference (approximate).\n\n\n\n\n\n","category":"constant"},{"location":"every/#ThreeBodyTB.Atomdata.atom_radius","page":"Additional Docstrings","title":"ThreeBodyTB.Atomdata.atom_radius","text":"atom_radius::Dict()\n\nAtomic radius (metallic), in pm\n\n\n\n\n\n","category":"constant"},{"location":"every/#ThreeBodyTB.Atomdata.atoms","page":"Additional Docstrings","title":"ThreeBodyTB.Atomdata.atoms","text":"atoms::Dict()\n\nPeriodic table information.\n\n\n\n\n\n","category":"constant"},{"location":"every/#ThreeBodyTB.Atomdata.cutoff_dist","page":"Additional Docstrings","title":"ThreeBodyTB.Atomdata.cutoff_dist","text":"cutoff_dist::Dict()\n\nCutoff distance for Hamiltonian calculation\n\n\n\n\n\n","category":"constant"},{"location":"every/#ThreeBodyTB.Atomdata.electronegativity","page":"Additional Docstrings","title":"ThreeBodyTB.Atomdata.electronegativity","text":"electronegativity::Dict()\n\nPauling scale.\n\n\n\n\n\n","category":"constant"},{"location":"every/#ThreeBodyTB.Atomdata.min_dimer_dist_dict","page":"Additional Docstrings","title":"ThreeBodyTB.Atomdata.min_dimer_dist_dict","text":"min_dimer_dist_dict::Dict()\n\nApproximate minimum distance in current fitting data.\n\n\n\n\n\n","category":"constant"},{"location":"every/#ThreeBodyTB.Atomdata.sub_list","page":"Additional Docstrings","title":"ThreeBodyTB.Atomdata.sub_list","text":"sub_list::Dict()\n\nMost likely substitution list, approximate.\n\n\n\n\n\n","category":"constant"},{"location":"every/#AtomicMod","page":"Additional Docstrings","title":"AtomicMod","text":"","category":"section"},{"location":"every/","page":"Additional Docstrings","title":"Additional Docstrings","text":"Modules = [ThreeBodyTB.AtomicMod]","category":"page"},{"location":"every/#ThreeBodyTB.AtomicMod","page":"Additional Docstrings","title":"ThreeBodyTB.AtomicMod","text":"module AtomicMod\n\nSimple module for atom type.\n\n\n\n\n\n","category":"module"},{"location":"every/#ThreeBodyTB.AtomicMod.atom","page":"Additional Docstrings","title":"ThreeBodyTB.AtomicMod.atom","text":"struct atom\n\nHold basic atomic information\n\nname::String \nZ::Int64 Atomic number\nrow::Float64 Periodic table row\ncol::Float64 Periodic table col\nmass::Float64 Mass in amu \nnval::Float64 Number of valence electrons in TB calculation.\nnsemicore::Int64 Number of semicore electrons. Depends on pseudopotential choice\nnwan::Int64 Number of TB orbitals\norbitals::Array{Symbol,1} Names of the orbitals, like [:s, :p]\ntotal_energy::Float64 DFT total energy, depends on pseudopotentials.\neigs::Dict orbital eigenvalues of isolated non-spin-polarized nuetral atom.\nenergy_offset::Float64 energy to add to TB calculation to make isolated atoms have zero energy.\nU::Float64 U value for Ewald correction\n\n\n\n\n\n","category":"type"},{"location":"every/#ThreeBodyTB.AtomicMod.makeatom","page":"Additional Docstrings","title":"ThreeBodyTB.AtomicMod.makeatom","text":"function makeatom(name, Z, row, col, mass, nval, nsemicore, orbitals, etot, eigs, vac_potential=0.0, U=0.0)\n\nConstructor for atom.\n\n\n\n\n\n","category":"function"},{"location":"every/#BandTools","page":"Additional Docstrings","title":"BandTools","text":"","category":"section"},{"location":"every/","page":"Additional Docstrings","title":"Additional Docstrings","text":"Modules = [ThreeBodyTB.BandTools]","category":"page"},{"location":"every/#ThreeBodyTB.BandTools","page":"Additional Docstrings","title":"ThreeBodyTB.BandTools","text":"module BandTools\n\nUtility functions for manipulating band structures. These need to be defined early in the code so other Modules have acccess to them.\n\n\n\n\n\n","category":"module"},{"location":"every/#ThreeBodyTB.BandTools.band_energy","page":"Additional Docstrings","title":"ThreeBodyTB.BandTools.band_energy","text":"function band_energy(eigs, weights, nelec, smearing = 0.01; returnk=false, returnocc=false, returnef=false, returnboth=false)\n\nCalculate band energy. Has options for additional return variables. Calculates fermi energy internally.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.BandTools.calc_fermi","page":"Additional Docstrings","title":"ThreeBodyTB.BandTools.calc_fermi","text":"function calc_fermi(eigs, weights, nelec, smearing = 0.01)\n\ncalculate fermi energy using bisection\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.BandTools.smearing_energy","page":"Additional Docstrings","title":"ThreeBodyTB.BandTools.smearing_energy","text":"function smearing_energy(eigs, weights, efermi, smearing = 0.01)\n\nSmearing contribution to total energy. If you don't take this int account in metals or  small gap semiconductors, your energy is not variational  in the correct way, and things like forces and stresses become wrong.\n\n\n\n\n\n","category":"function"},{"location":"every/#CalcTB","page":"Additional Docstrings","title":"CalcTB","text":"","category":"section"},{"location":"every/","page":"Additional Docstrings","title":"Additional Docstrings","text":"Modules = [ThreeBodyTB.CalcTB]","category":"page"},{"location":"every/#ThreeBodyTB.CalcTB","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB","text":"module CalcTB\n\nCreate TB matrix sets from coefficients, or prepare to fit the coefficients.\n\n\n\n\n\n","category":"module"},{"location":"every/#ThreeBodyTB.CalcTB.coefs","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.coefs","text":"struct coefs\n\nHold the TB coefficients for 2body or 3body interactions\n\ndim::Int64 - dimension (2 or 3)\ndatH::Array{Float64,1} Hamiltonian parameters\ndatS::Array{Float64,1}  Overlap parameters, if any\nsizeH::Int64 \nsizeS::Int64\ninds::Dict{Array{Symbol}, Array{Int64,1}} Holds inds that tell which coeffiecients correspond to which atoms/orbitals\nnames::Set Names of atoms\norbs::Array{Any,1} Orbitals \ncutoff::Float64 cutoff distance\nmin_dist::Float64 minimum atom-atom distance in fitting data\nmaxmin_val_train::Dict max and min value of matrix elements within fitting data\ndist_frontier::Dict dictionary of pareto frontier of shortest fitting distances\nversion::Int64 version number\n\n\n\n\n\n","category":"type"},{"location":"every/#ThreeBodyTB.CalcTB.calc_frontier-Tuple{crystal, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.calc_frontier","text":"function calc_frontier(crys::crystal, frontier; var_type=Float64, test_frontier=false, diststuff=missing, verbose=true)\n\nCalculate a pareto frontier of short distances. For 2body interactions, this is just a single distance, which is easy. For 3body interactions, there are 3 distances, so multiple points are on the frontier. Useful for deciding if old fitting data applies to a new structure with atoms that are close together.\n\ntest_frontier=true is used to check if new structure is in the frontier. othersise, see if new structure changes frontier.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.CalcTB.calc_onsite","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.calc_onsite","text":"function calc_onsite(t1,s1,s2, database=missing)\n\nHandles atomic matrix els. We do not currently fit onsite matrix els\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.CalcTB.calc_tb_fast","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.calc_tb_fast","text":"calc_tb_fast(crys::crystal; database=missing, use_threebody=true, use_threebody_onsite=true)\n\nConstruct tb_crys from crystal stucture, but does not solve. This is usually called internally by functions like scf_energy, but you can use it directly if you want. Until you do a SCF energy calculation, the electron density and Fermi level will be wrong.\n\nArguments\n\ncrys::crystal - Required crystal structure\ndatabase=missing - Source of coefficients. Will load from default source if not specified.\nuse_threebody=true - Use three-body off-site interactions. Only turn off for testing purposes.\nuse_threebody_onsite=true - Use three-body on-site interactions. Only turn off for testing purposes.\nverbose=true - set to false for less output.\nvar_type=missing - variable type of tb_crys. Default is Float64.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.CalcTB.calc_tb_prepare_fast-Tuple{tb_crys}","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.calc_tb_prepare_fast","text":"function calc_tb_prepare_fast(reference_tbc::tb_crys; use_threebody=false, use_threebody_onsite=false)\n\nTake a tbc from DFT and rearrange it for use in fitting code. Basically set it up so that it is ready for a least squares linear fit of coefficients.\n\nreturn twobody_arrays, threebody_arrays, hvec, svec, Rvec, INDvec, h_onsite, ind_conversion, dmin_types, dmin_types3\n\nWhere\n\ntwobody_arrays - info for fitting twobody coefficients\nthreebody_array - info for fitting twobody coefficients\nhvec - vector of reference TB matrix els, arranged for fitting\nsvec - vector of reference overlap matrix els, arranged for fitting\nRvec - displaments\nINDvec info on which matrix el goes with which row\nh_onsite info for subtracting atomic terms, I think\nind_conversion - dict to convert between place in hamiltonian and overall counter, which removes duplicates.\ndmin_types - shortest 2body distances\ndmin_types - shortest 3body distances\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.CalcTB.calc_threebody-NTuple{13, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.calc_threebody","text":"function calc_threebody(c,ind, t1,t2,t3,orb1,orb2,dist,dist31,dist32,lmn12, lmn31,lmn32; database=missing, memory0=missing, memory1=missing, memory2=missing, memoryV=missing, precalc=false, set_maxmin=false)\n\nCalculate 3body intersite hamiltonian interactions.\n\nmemory1, etc have preallocated memory. This function is important for performance.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.CalcTB.calc_threebody_onsite-NTuple{7, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.calc_threebody_onsite","text":"function calc_threebody_onsite(t1,t2,t3,orb1,dist12,dist13,dist23, database; set_maxmin=false, memory=missing)\n\ncalculate threebody onsite interactions\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.CalcTB.calc_twobody-NTuple{7, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.calc_twobody","text":"function calc_twobody(t1,t2,orb1,orb2,dist,lmn, database)\n\nTwo body intersite Hamiltonian and overlap matrix els.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.CalcTB.calc_twobody_onsite-NTuple{7, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.calc_twobody_onsite","text":"function calc_twobody_onsite(t1,t2,orb1,orb2, dist,lmn, database)\n\nCalculate 2body onsite interactions.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.CalcTB.distances_etc","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.distances_etc","text":"function distances_etc(crys, cutoff, cutoff2=missing)\n\nOld distance function, no threebody only twobody. Code primarly uses distances_etc_3bdy_parallel\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.CalcTB.distances_etc_3bdy_parallel","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.distances_etc_3bdy_parallel","text":"function distances_etc_3bdy_parallel(crys, cutoff=missing, cutoff2=missing; var_type=Float64)\n\nFinds atoms-atom and atom-atom-atom distances that are less than the cutoffs.\n\nreturn R_keep, R_keep_ab, array_ind3, array_floats3, dist_arr, c_zero, dmin_types, dmin_types3\n\nWhere\n\nR_keep has the supercells that are necessary\nR_keep_ab has the 2body indexes that are less than the cutoff\narray_ind3 has the 3body indexes\narray_floats3 has the 3body actual distances and lmn.\ndist_arr has the actual 2body distances\nc_zero the index of cell [0,0,0], the onsite cell\ndmin_types minimum distance between types of atoms.\ndmin_types3 minimum 3body distances between types of atoms.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.CalcTB.fit_threebody-NTuple{11, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.fit_threebody","text":"function fit_threebody(t1,t2,t3,orb1,orb2,dist,dist31,dist32,lmn12, lmn31,lmn32)\n\nFit threebody intersite interactions\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.CalcTB.fit_threebody_onsite-NTuple{6, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.fit_threebody_onsite","text":"function fit_threebody_onsite(t1,t2,t3,orb1,dist12,dist13,dist23)\n\nFit three body onsite interactions.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.CalcTB.fit_twobody-NTuple{4, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.fit_twobody","text":"function fit_twobody(orb1,orb2,dist,lmn)\n\nFit Two body intersite Hamiltonian and overlap matrix els.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.CalcTB.fit_twobody_onsite-NTuple{6, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.fit_twobody_onsite","text":"function fit_twobody_onsite(t1,t2,orb1,orb2, dist,lmn)\n\nFit 2body onsite interactions.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.CalcTB.get_data_info_v1-Tuple{Any, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.get_data_info_v1","text":"function get_data_info(at_set, dim)\n\nFigure out the arrangement of data in a coefs file.\n\nLoops over various combinations of orbitals and atoms and assigns them places in datH and datS, depending on the terms included in the model and the dimensionaly.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.CalcTB.get_data_info_v2-Tuple{Any, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.get_data_info_v2","text":"function get_data_info(at_set, dim)\n\nFigure out the arrangement of data in a coefs file.\n\nLoops over various combinations of orbitals and atoms and assigns them places in datH and datS, depending on the terms included in the model and the dimensionaly.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.CalcTB.laguerre","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.laguerre","text":"function laguerre(dist, ind=missing; nmax=6, memory=missing)\n\nCalculate laguerre polynomials up to order nmax\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.CalcTB.make_coefs-Tuple{Any, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.make_coefs","text":"function make_coefs(at_list, dim; datH=missing, datS=missing, cutoff=18.01, min_dist = 3.0, fillzeros=false, maxmin_val_train=missing, dist_frontier=missing)\n\nConstructor for coefs. Can create coefs filled with ones for testing purposes.\n\nSee coefs to understand arguments.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.CalcTB.plot_database","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.plot_database","text":"function plot_database(database, entry, t=missing)\n\nPlot some data from coefs. Needs to be updated to work with Plots, probably doesn't work now.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.CalcTB.read_coefs","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.read_coefs","text":"function read_coefs(filename, directory = missing)\n\nRead coefs from filename. Can read gzip directly.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.CalcTB.renormalize_S","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.renormalize_S","text":"function renormalize_S(tbc, database, cutoff=17.99)\n\nFunction for changing S but keeping the band structure fixed. Not currently used.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.CalcTB.symmetry_factor-NTuple{4, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.symmetry_factor","text":"function symmetry_factor(s1,s2,lmn, dat)\n\nAll of the spd Slater-Koster matrix elements. dat is preallocated memory.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.CalcTB.symmetry_factor_fit-Tuple{Any, Any, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.symmetry_factor_fit","text":"function symmetry_factor_fit(s1,s2,lmn)\n\nAll the Slater-Koster factors, for fitting.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.CalcTB.three_body_H","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.three_body_H","text":"function two_body_H(dist, ind=missing)\n\nget 3body hamiltonian terms together.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.CalcTB.three_body_O","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.three_body_O","text":"function two_body_O(dist, ind=missing)\n\nthree body onsite.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.CalcTB.trim_dist","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.trim_dist","text":"function trim_dist(tbc, cutoff=18.0001)\n\nReduce the atom-atom hamiltonian terms longer than cutoff.\n\nNot used in typical code, but can make tbc run faster / reduce memory.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.CalcTB.two_body_H","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.two_body_H","text":"function two_body_H(dist, ind=missing)\n\nTwo body intersite Hamiltonian.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.CalcTB.two_body_O","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.two_body_O","text":"function two_body_O(dist, ind=missing)\n\nTwo body onsite\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.CalcTB.two_body_S","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.two_body_S","text":"function two_body_H(dist, ind=missing)\n\nTwo body intersite overlap.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.CalcTB.write_coefs-Tuple{Any, ThreeBodyTB.CalcTB.coefs}","page":"Additional Docstrings","title":"ThreeBodyTB.CalcTB.write_coefs","text":"function write_coefs(filename, co::coefs; compress=true)\n\nWrite coefs to a file. Compress uses gzip. See read_coefs\n\n\n\n\n\n","category":"method"},{"location":"every/#CrystalMod","page":"Additional Docstrings","title":"CrystalMod","text":"","category":"section"},{"location":"every/","page":"Additional Docstrings","title":"Additional Docstrings","text":"ThreeBodyTB.CrystalMod.parsePOSCAR\nThreeBodyTB.CrystalMod.parseQEinput\nThreeBodyTB.CrystalMod.generate_supercell\nThreeBodyTB.CrystalMod.generate_random_distortion\nThreeBodyTB.CrystalMod.write_poscar\nThreeBodyTB.CrystalMod.write_efs\nThreeBodyTB.CrystalMod.get_grid\nThreeBodyTB.CrystalMod.orbital_index","category":"page"},{"location":"every/#ThreeBodyTB.CrystalMod.parsePOSCAR","page":"Additional Docstrings","title":"ThreeBodyTB.CrystalMod.parsePOSCAR","text":"function parsePOSCAR(lines)\n\nParse a POSCAR from VASP\n\nCalled by makecrys, doesn't need to be called directly.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.CrystalMod.parseQEinput","page":"Additional Docstrings","title":"ThreeBodyTB.CrystalMod.parseQEinput","text":"function parseQEinput(lines)\n\nParse a quantum espresso inputfile. Can only handle simple cases with explict CELL_PARAMETERS Cannot handle nonzero ibrav. or celldm\n\nCalled by makecrys, doesn't need to be called directly.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.CrystalMod.generate_supercell","page":"Additional Docstrings","title":"ThreeBodyTB.CrystalMod.generate_supercell","text":"function generate_supercell(crys, cell)\n\nGenerate supercell. cell is [1,1,2], etc. \n\nNote, perfered notation is to use syntax: c * [1,1,2] , where c is a crystal, thus  using overloading of the * operator,  rather than calling directly.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.CrystalMod.generate_random_distortion","page":"Additional Docstrings","title":"ThreeBodyTB.CrystalMod.generate_random_distortion","text":"function generate_random_distortion(crys, amag, strain_mag)\n\nRandomly distort a crystal. amag is the atom distance, strain_mag is the strain magnitude\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.CrystalMod.write_poscar","page":"Additional Docstrings","title":"ThreeBodyTB.CrystalMod.write_poscar","text":"function write_poscar(crys, filename)\n\nWrite a crystal to a POSCAR.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.CrystalMod.write_efs","page":"Additional Docstrings","title":"ThreeBodyTB.CrystalMod.write_efs","text":"function function write_efs(crys, energy, forces, stress, filename)\n\nWrite crystal, energy, force, stress to fake quantum espresso output file. This is for testing purposes only.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.CrystalMod.get_grid","page":"Additional Docstrings","title":"ThreeBodyTB.CrystalMod.get_grid","text":"function get_grid(c, kden=55.0)\n\nGet a default k-point grid size with kden density.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.CrystalMod.orbital_index","page":"Additional Docstrings","title":"ThreeBodyTB.CrystalMod.orbital_index","text":"function orbital_index(c::crystal)\n\nGet correspondence between crystal and the TB orbital numbers.\n\nreturn ind2orb, orb2ind, etotal, nval\n\nind2orb dictionary which gives [atom_number,atom_type, :orbital_symbol] from TB index integer.\norb2ind dictionary which gives TB index integer from [atom_number,atom_type, :orbital_symbol]\netotal total DFT energy of atoms, for calculation atomization energy.\nnval number of valence orbitals.\n\n\n\n\n\n","category":"function"},{"location":"every/#DFToutMod","page":"Additional Docstrings","title":"DFToutMod","text":"","category":"section"},{"location":"every/","page":"Additional Docstrings","title":"Additional Docstrings","text":"Modules = [ThreeBodyTB.DFToutMod]","category":"page"},{"location":"every/#ThreeBodyTB.DFToutMod","page":"Additional Docstrings","title":"ThreeBodyTB.DFToutMod","text":"module DFToutMod\n\nDeal with energy, force, stress, band structure, etc, from a DFT calculation\n\nGeneric to different DFT codes.\n\n\n\n\n\n","category":"module"},{"location":"every/#ThreeBodyTB.DFToutMod.bandstructure","page":"Additional Docstrings","title":"ThreeBodyTB.DFToutMod.bandstructure","text":"mutable struct bandstructure\n\nBand structure. Has\n\nnbnd::Int Number of bands\nnks::Int Number of k-points\nnelec::Float64 Number of electrons\nefermi::Float64 Fermi energy\nkpts::Array{Float64,2} List of k-points, nks × 3 array in BZ crystal units.\nkweights::Array{Float64,1} Weights of k-points (nks).\nkgrid::Array{Int,1} Equivalent gamma centered Monkhorst-Pack k-grid dimensions, if applies.\neigs::Array{Float64,2} Eigenvalues. nks × nbnd\n\n\n\n\n\n","category":"type"},{"location":"every/#ThreeBodyTB.DFToutMod.dftout","page":"Additional Docstrings","title":"ThreeBodyTB.DFToutMod.dftout","text":"mutable struct dftout\n\nDFT output struct. Has\n\ncrys::crystal  crystal structure\nenergy::Float64 the actual DFT energy, depends on pseudopotentials.\nenergy_smear::Float64 smearing energy\nforces::Array{Float64,2} forces Ryd / a.u.\nstress::Array{Float64,2} stress  Ryd / (a.u.)^3\nbandstruct::bandstructure See bandstructure struct\nhasband::Bool does this object have a band structure, usually true\nhasham::Bool not used, always false\nprefix::String  A string has a name used to find output files.\noutdir::String Directly loaded from\ntot_charge::Float64 If charge of unit cell is nonzero\natomize_energy::Float64 Atomization energy, relative to non-spin-polarized atoms.\n\n\n\n\n\n","category":"type"},{"location":"every/#ThreeBodyTB.DFToutMod.get_atomize_energy-Tuple{dftout}","page":"Additional Docstrings","title":"ThreeBodyTB.DFToutMod.get_atomize_energy","text":"function get_atomize_energy(d::dftout)\n\nReturn atomization energy in current energy units\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.DFToutMod.makebs-Tuple{Number, Number, Any, Any, Any, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.DFToutMod.makebs","text":"function makebs(nelec::Number, efermi::Number,  kpoints, kweights,kgrid, vals)\n\nConstructor for bandstructure.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.DFToutMod.makedftout","page":"Additional Docstrings","title":"ThreeBodyTB.DFToutMod.makedftout","text":"function makedftout(A, pos, types, energy::Number,energy_smear::Number,  forces, stress, bandstruct=missing; prefix=\"PREFIX\", outdir=\"TMPDIR\", tot_charge=0.0)\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.DFToutMod.makedftout-2","page":"Additional Docstrings","title":"ThreeBodyTB.DFToutMod.makedftout","text":"function makedftout(crys::crystal, energy::Number, energy_smear::Number,  forces, stress, bandstruct=missing; prefix=\"PREFIX\", outdir=\"TMPDIR\", tot_charge=0.0)\n\nConstructor for dftout. Usually called by function that loads DFT output files, not called directly.\n\n\n\n\n\n","category":"function"},{"location":"every/#DFT","page":"Additional Docstrings","title":"DFT","text":"","category":"section"},{"location":"every/","page":"Additional Docstrings","title":"Additional Docstrings","text":"Modules = [ThreeBodyTB.DFT]","category":"page"},{"location":"every/#ThreeBodyTB.DFT","page":"Additional Docstrings","title":"ThreeBodyTB.DFT","text":"module DFT\n\nThis is the generic DFT interface. Only QE is currently implemented however.\n\n\n\n\n\n","category":"module"},{"location":"every/#ThreeBodyTB.DFT.runSCF-Tuple{crystal}","page":"Additional Docstrings","title":"ThreeBodyTB.DFT.runSCF","text":"function runSCF(crys::crystal; inputstr=missing, prefix=missing, tmpdir=\"./\", directory=\"./\", functional=\"PBESOL\", wannier=0, nprocs=1, code=\"QE\", skip=false, calculation=\"scf\", dofree=\"all\", tot_charge = 0.0, smearing = missing, magnetic=false, cleanup=false, use_backup=false)\n\nWorkflow for generic DFT SCF calculation. code can only by \"QE\"\n\n\n\n\n\n","category":"method"},{"location":"every/#QE","page":"Additional Docstrings","title":"QE","text":"","category":"section"},{"location":"every/","page":"Additional Docstrings","title":"Additional Docstrings","text":"Modules = [ThreeBodyTB.QE]","category":"page"},{"location":"every/#ThreeBodyTB.QE","page":"Additional Docstrings","title":"ThreeBodyTB.QE","text":"module QE\n\nModule for running Quantum Espresso. Generic DFT version below.\n\n\n\n\n\n","category":"module"},{"location":"every/#ThreeBodyTB.QE.doclean-Tuple{Any}","page":"Additional Docstrings","title":"ThreeBodyTB.QE.doclean","text":"function doclean(d)\n\nClean up wavefunctions in directory d\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.QE.loadXML-Tuple{Any}","page":"Additional Docstrings","title":"ThreeBodyTB.QE.loadXML","text":"function loadXML(savedir)\n\nLoad a QE SCF DFT calculation into a dftout object.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.QE.loadXML_bs-Tuple{Any}","page":"Additional Docstrings","title":"ThreeBodyTB.QE.loadXML_bs","text":"function loadXML_bs(savedir::String)\n\nLoad bandstructure from QE xml file that was converted to a dict already\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.QE.loadXML_bs-Tuple{String}","page":"Additional Docstrings","title":"ThreeBodyTB.QE.loadXML_bs","text":"function loadXML_bs(savedir::String)\n\nLoad bandstructure from QE xml file.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.QE.makeSCF","page":"Additional Docstrings","title":"ThreeBodyTB.QE.makeSCF","text":"function makeSCF(crys::crystal, directory=\"./\", prefix=missing, tmpdir=missing, functional=\"PBESOL\", wannier=0, calculation=\"scf\", dofree=\"all\", tot_charge = 0.0, smearing = 0.01, magnetic=false; mixing=\"local-TF\")\n\nMake QE inputfile for SCF DFT calculation.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.QE.make_commands","page":"Additional Docstrings","title":"ThreeBodyTB.QE.make_commands","text":"function make_commands(nprocs=1)\n\nReturns a dictionary with command lines to call external programs on the command line nprocs is the number of processors for parallel execution Needs to be changed for you specfic program locations  and mpi commands (if any)\n\nThis needs to be edited to actually run QE yourself. Running wannier90 is optional, not part of current code.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.QE.makedict-Tuple{Any}","page":"Additional Docstrings","title":"ThreeBodyTB.QE.makedict","text":"function makedict(savedir)\n\nLoad a data-file-schema.xml as julia dictionary.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.QE.runSCF","page":"Additional Docstrings","title":"ThreeBodyTB.QE.runSCF","text":"function runSCF(crys::crystal, inputstr=missing, prefix=missing, tmpdir=\"./\", directory=\"./\", functional=\"PBESOL\", wannier=0, nprocs=1, skip=false, calculation=\"scf\", dofree=\"all\", tot_charge = 0.0, smearing = 0.01, magnetic=false, cleanup=false, use_backup=false)\n\nWorkflow for doing SCF DFT calculation on crys\n\nReturn dftout\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.QE.run_pwscf","page":"Additional Docstrings","title":"ThreeBodyTB.QE.run_pwscf","text":"function run_pwscf(inputstr, outputstr, nprocs=1, directory=\"./\", use_backup=false)\n\nRun the pw.x code from QE on inputstr\n\n\n\n\n\n","category":"function"},{"location":"every/#Ewald","page":"Additional Docstrings","title":"Ewald","text":"","category":"section"},{"location":"every/","page":"Additional Docstrings","title":"Additional Docstrings","text":"Modules = [ThreeBodyTB.Ewald]","category":"page"},{"location":"every/#ThreeBodyTB.Ewald","page":"Additional Docstrings","title":"ThreeBodyTB.Ewald","text":"module Ewald\n\nModule for electrostatic preperation.\n\n\n\n\n\n","category":"module"},{"location":"every/#ThreeBodyTB.Ewald.electrostatics_getgamma-Tuple{crystal}","page":"Additional Docstrings","title":"ThreeBodyTB.Ewald.electrostatics_getgamma","text":"function electrostatics_getgamma(crys::crystal;  kappa=missing, noU=false, onlyU=false, screening = 1.0)\n\nMain function. Does Ewald calculation on crys. Returns gamma, which is used in scf calculation. This is only run once for a given tb_crys object and stored.\n\nkappa is the splitting parameter between real/k-space in Ewald calculation. Will estimate best one if not provided.\nnoU=false for testing only\nonlyU=false for testing only\nscreening=1.0 Not used. Purpose is to reduce U values for values < 1.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.Ewald.estimate_best_kappa-Tuple{Any}","page":"Additional Docstrings","title":"ThreeBodyTB.Ewald.estimate_best_kappa","text":"function estimate_best_kappa(A)\n\nEstimate best value of kappa for Ewald sum. Shouldn't effect final value, only calculation speed. There is probably a better way to do this.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.Ewald.getU-Tuple{Any}","page":"Additional Docstrings","title":"ThreeBodyTB.Ewald.getU","text":"function getU(types)\n\nGet values of U from Atomdata.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.Ewald.get_onsite-Tuple{crystal, Vector{Float64}}","page":"Additional Docstrings","title":"ThreeBodyTB.Ewald.get_onsite","text":"function get_onsite(crys::crystal, U::Array{Float64,1})\n\nreturn Onsite terms, Coulumb U.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.Ewald.k_space","page":"Additional Docstrings","title":"ThreeBodyTB.Ewald.k_space","text":"function k_space(crys::crystal, kappa, starting_size_kspace=2)\n\nK-space Ewald sum.\n\n\n\n\n\n","category":"function"},{"location":"every/#ThreeBodyTB.Ewald.real_space","page":"Additional Docstrings","title":"ThreeBodyTB.Ewald.real_space","text":"function real_space(crys::crystal, kappa::Float64, U::Array{Float64}, starting_size_rspace=2)\n\nReal-space Ewald sum.\n\n\n\n\n\n","category":"function"},{"location":"every/#FitTB","page":"Additional Docstrings","title":"FitTB","text":"","category":"section"},{"location":"every/","page":"Additional Docstrings","title":"Additional Docstrings","text":"Modules = [ThreeBodyTB.FitTB]","category":"page"},{"location":"every/#ThreeBodyTB.FitTB.do_fitting-Tuple{Any}","page":"Additional Docstrings","title":"ThreeBodyTB.FitTB.do_fitting","text":"function do_fitting(list_of_tbcs; kpoints = missing,  atoms_to_fit=missing, fit_threebody=true, fit_threebody_onsite=true, do_plot = true)\n\nUsed for simple linear fitting of coefficients. Interface for more complicated fitting.\n\nlist_of_tbcs - List of tbc_crys or tbccrysk` objects to fit to.\ndft_list - for kspace fitting, use \nfit_threebody=true - Fit threebody coefficients. Sometimes false for testing, but true for production.\nfit_threebody_onsite=true - Fit threebody onsite coefficients. See above.\ndo_plot=true - show simple plot comparing coefficients to tbc reference.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.FitTB.do_fitting_linear-Tuple{Any}","page":"Additional Docstrings","title":"ThreeBodyTB.FitTB.do_fitting_linear","text":"function do_fitting_linear(list_of_tbcs; kpoints = missing, dft_list = missing,  fit_threebody=true, fit_threebody_onsite=true, do_plot = true, starting_database=missing, mode=:kspace, return_database=true, NLIM=100, refit_database=missing)\n\nLinear fitting (not recursive). Used as starting point of recursive fitting.\n\nArguments.\n\nlist_of_tbcs The main data to fit to. Consists of a list of tb_crys or tb_crys_kspace objects.\nkpoints = missing Kpoints to do fitting to in k-space. Usually, this is not used, see below.\ndft_list = missing List of dftout objects. Normally, we get symmetry reduced k-grids from these objects.\nfit_threebody=true Fit three body coefficients. Yes for production runs.\nfit_threebody_onsite=true Fit 3body onsite coefficients. Yes for production runs.\ndo_plot = true Make a plot to assess fitting. \nstarting_database=missing Use a database dict with some of the coefficents already fit and fixed.\nmode=:kspace Fit in either :kspace or :rspace. Can only use r-space if using only tbc_crys real-space objects to fit to. :kspace is normal.\nreturn_database=true Return the final database. For use when called by other functions.\nNLIM=100 Largest number of k-points per structure. Set to smaller numbers to make code go faster / reduce memory, but may be less accurate.\nrefit_database=missing starting point for coefficients we are fitting. Usually not used, as it doesn't always speed things up in practice. Something may not work about this option.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.FitTB.do_fitting_recursive-Tuple{Any}","page":"Additional Docstrings","title":"ThreeBodyTB.FitTB.do_fitting_recursive","text":"function do_fitting_recursive(list_of_tbcs ; weights_list = missing, dft_list=missing, X_cv = missing, kpoints = [0 0 0; 0 0 0.5; 0 0.5 0.5; 0.5 0.5 0.5], starting_database = missing,  update_all = false, fit_threebody=true, fit_threebody_onsite=true, do_plot = false, energy_weight = missing, rs_weight=missing,ks_weight=missing, niters=50, lambda=0.0, leave_one_out=false, prepare_data = missing, RW_PARAM=0.0, NLIM = 100, refit_database = missing, start_small = false)\n\nThis is the primary function for fitting. Uses the self-consistent linear fitting algorithm.\n\nArguments\n\nlist_of_tbcs List of tbc_crys or tbc_crys_kspace object to fit to.\nweights_list = missing relative weights of different tbc objects in fitting code.\ndft_list=missing List of dftout objects used to get symmetry-reduced kpoint lists / weights to use in kspace fitting.\nkpoints = [0 0 0; 0 0 0.5; 0 0.5 0.5; 0.5 0.5 0.5] alternate way of setting k-points, not usually used.\nstarting_database = missing If using already fit coefficents for some of the atoms, from another calculation, include that database dict here.\nupdate_all = false If updateall is true, then we refit the starting coefficients from `startingdatabase. Normallyfalse` except for testing.\nfit_threebody=true Fit 3body intersite coefficents. true for production runs.\nfit_threebody_onsite=true Fit 3body onsite coefficents. true for production runs.\ndo_plot = false make plot for the linear fit.\nenergy_weight = missing Weighting for the total energy terms in the fit.\nrs_weight=missing Real space hamiltonian matrix els weighting. zero for pure k-space fit.\nks_weight=missing  K-space hamiltonian matrix els weighting. Set to zero to ignore hamiltonian matrix els and only fit to band structure.\nniters=50 Maximum number of iterations.\nlambda=0.0  If greater than zero, include a simple ridge regression with this lambda value. Usually zero.\nleave_one_out=false  Leave-one-out cross-validation. Too slow to be very useful.\nprepare_data = missing Rarely used option to reuse previous linear fitting.\nRW_PARAM=0.0 Weighting of non-occupied bands in fit.\nNLIM = 100 Maximum k-points per structure. Smaller for faster but less accurate fit that uses less memory.\nrefit_database = missing Option to include starting data. Rarely used.\nstart_small = false When fitting only 3body data, setting this to true will start the 3body terms with very small values, which can improve convergence. Not useful if also fitting 2body terms.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.FitTB.extract_database-NTuple{6, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.FitTB.extract_database","text":"function extract_database(database_old,nh,ns, KEYS, HIND, SIND)\n\nIf we are using fixed prefit coefficients, we have to get them in the same form as our current fitting.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.FitTB.fourierspace-NTuple{13, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.FitTB.fourierspace","text":"function fourierspace(tbc, kpoints, X_H, X_S, Y_H, Y_S, Xhc, Xsc, rind, Rvec, INDVec, h_on, ind_convert)\n\nDo analytic fourier transform of real space fitting matrices into kspace.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.FitTB.get_k-Tuple{Any, Any, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.FitTB.get_k","text":"function get_k(dft_list, ncalc; NLIM = 100)\n\nDecide which k-points to include in fitting, as we limit the total number to NLIM or less per structure\n\nUses some randomness, but puts high symmetry points at front of line.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.FitTB.hermetian_index-Tuple{Int64, Int64, Int64}","page":"Additional Docstrings","title":"ThreeBodyTB.FitTB.hermetian_index","text":"function hermetian_index(i::Int64,j::Int64,nwan::Int64)\n\nThis is used to reduce memory by only keeping track of independet coefficients of Hermetian matrices, which is nearly a factor of 2 reduction.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.FitTB.make_database-NTuple{7, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.FitTB.make_database","text":"function make_database(ch, cs,  KEYS, HIND, SIND, DMIN_TYPES, DMIN_TYPES3; scf=false, starting_database=missing, tbc_list=missing)\n\nConstruct the coefs and database from final results of fitting.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.FitTB.prepare_for_fitting-Tuple{Any}","page":"Additional Docstrings","title":"ThreeBodyTB.FitTB.prepare_for_fitting","text":"function prepare_for_fitting(list_of_tbcs; kpoints = missing, dft_list = missing, fit_threebody=false, fit_threebody_onsite=false, starting_database=missing, refit_database=missing)\n\nMake lots of preperations for fitting. Moves things around, put stuff in materices, etc.\n\n\n\n\n\n","category":"method"},{"location":"every/#Force_Stress","page":"Additional Docstrings","title":"Force_Stress","text":"","category":"section"},{"location":"every/","page":"Additional Docstrings","title":"Additional Docstrings","text":"Modules = [ThreeBodyTB.Force_Stress]","category":"page"},{"location":"every/#ThreeBodyTB.Force_Stress","page":"Additional Docstrings","title":"ThreeBodyTB.Force_Stress","text":"module Force_Stress\n\nModule for calculating force and stress\n\n\n\n\n\n","category":"module"},{"location":"every/#ThreeBodyTB.Force_Stress.finite_diff-Tuple{crystal, Any, Any, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.Force_Stress.finite_diff","text":"function finite_diff(crys::crystal, database, ind1, ind2; stress_mode=false, step = 0.0002, smearing = 0.01, grid = missing)\n\nFinite differences force/stress, for testing.\n\nArguments\n\ncrys::crystal Crystal structure\ndatabase Database of fitting coefficents.\nind1  atom index for first stress index\nind2 cartesian index or second stress index\nstress_mode=false true for stress, otherwise force.\nstep = 0.0002 step_size for finite steps.\nsmearing = 0.01 smearing energy\ngrid = missing kpoint grid\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.Force_Stress.get_energy_force_stress-Tuple{crystal, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.Force_Stress.get_energy_force_stress","text":"function get_energy_force_stress(crys::crystal, database; smearing = 0.01, grid = missing)\n\nGet force and stress, non-fft algorithm. Generally use the fft algorithm.\n\nreturn energy_tot,  f_cart, stress\n\nReturns Ryd units. Generally users should use the scf_energy_force_stress function\n\nUses automatic differentation for gradient.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.Force_Stress.get_energy_force_stress-Tuple{tb_crys, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.Force_Stress.get_energy_force_stress","text":"function get_energy_force_stress(crys::crystal, database; smearing = 0.01, grid = missing)\n\nGet force and stress, non-fft algorithm\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.Force_Stress.get_energy_force_stress_fft-Tuple{tb_crys, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.Force_Stress.get_energy_force_stress_fft","text":"function get_energy_force_stress_fft(tbc::tb_crys, database; do_scf=false, smearing = 0.01, grid = missing, e_den0=missing, vv = missing)\n\nCalculate energy/force/stress using fft algorithm. Users should use scf_energy_force_stress, which calls this. Uses automatic differentation for jacobian.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.Force_Stress.inv_reshape_vec-Tuple{Any, Any, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.Force_Stress.inv_reshape_vec","text":"function inv_reshape_vec(x, strain, nat; strain_mode=true)\n\nThe force and relax algorithms from outside codes take in vectors, not crystal 's. So we have to reshape vectors to and from crystals\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.Force_Stress.psi_gradH_psi-NTuple{11, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.Force_Stress.psi_gradH_psi","text":"function psi_gradH_psi(VALS0, VECTS, hk_g, sk_g, h1, VALS, scf, nwan, nat, grid, OCCS)\n\nHelper function for <psi | grad_Ham | psi >\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.Force_Stress.psi_gradH_psi2-NTuple{11, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.Force_Stress.psi_gradH_psi2","text":"function psi_gradH_psi(VALS0, VECTS, hk_g, sk_g, h1, VALS, scf, nwan, nat, grid, OCCS)\n\nHelper function for <psi | grad_Ham | psi >\n\nThis version isn't used.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.Force_Stress.reshape_vec-Tuple{Any, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.Force_Stress.reshape_vec","text":"function reshape_vec(x, nat; strain_mode=false)\n\nThe force and relax algorithms from outside codes take in vectors, not crystal 's. So we have to reshape vectors to and from crystals\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.Force_Stress.safe_mode_energy-Tuple{crystal, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.Force_Stress.safe_mode_energy","text":"function safe_mode_energy(crys::crystal, database; var_type=Float64)\n\nRelaxation can accidently lead to very small atom-atom distances during the relaxation precedure if too large of step is taken. This function is a repulsive energy function at short range to make sure the relaxtion doesn't get stuck at very short distances where the fitting doesn't apply.\n\n\n\n\n\n","category":"method"},{"location":"every/#ManageDatabase","page":"Additional Docstrings","title":"ManageDatabase","text":"","category":"section"},{"location":"every/","page":"Additional Docstrings","title":"Additional Docstrings","text":"Modules = [ThreeBodyTB.ManageDatabase]","category":"page"},{"location":"every/#ThreeBodyTB.ManageDatabase","page":"Additional Docstrings","title":"ThreeBodyTB.ManageDatabase","text":"module ManageDatabase\n\nModule for reading coefs from files and making database as needed for calculations\n\n\n\n\n\n","category":"module"},{"location":"every/#ThreeBodyTB.ManageDatabase.add_to_database-Tuple{Set}","page":"Additional Docstrings","title":"ThreeBodyTB.ManageDatabase.add_to_database","text":"function add_to_database(s::Set)\n\nLoad elements or twobody terms from precalcuated coefs from files.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.ManageDatabase.clear_database-Tuple{}","page":"Additional Docstrings","title":"ThreeBodyTB.ManageDatabase.clear_database","text":"function clear_database()\n\nRemove loaded databasea\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.ManageDatabase.prepare_database-Tuple{Any}","page":"Additional Docstrings","title":"ThreeBodyTB.ManageDatabase.prepare_database","text":"function prepare_database(at_list)\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.ManageDatabase.prepare_database-Tuple{crystal}","page":"Additional Docstrings","title":"ThreeBodyTB.ManageDatabase.prepare_database","text":"function prepare_database(c::crystal)\n\nGet ready database of precalculated coefs for crystal\n\n\n\n\n\n","category":"method"},{"location":"every/#SCF","page":"Additional Docstrings","title":"SCF","text":"","category":"section"},{"location":"every/","page":"Additional Docstrings","title":"Additional Docstrings","text":"Modules = [ThreeBodyTB.SCF]","category":"page"},{"location":"every/#ThreeBodyTB.SCF","page":"Additional Docstrings","title":"ThreeBodyTB.SCF","text":"module SCF\n\nModule for self-consistent field calculations for TB objects.\n\n\n\n\n\n","category":"module"},{"location":"every/#ThreeBodyTB.SCF.remove_scf_from_tbc-Tuple{Any, Any, Any}","page":"Additional Docstrings","title":"ThreeBodyTB.SCF.remove_scf_from_tbc","text":"function remove_scf_from_tbc(hk3, sk3, tbc; smearing=0.01, e_den = missing)\n\nThis function takes a hk3, sk3 set of hamiltonian / overlap that does not require scf and adjusts it  so that it does require scf, but gives the same energy and band structure.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.SCF.remove_scf_from_tbc-Tuple{tb_crys_kspace}","page":"Additional Docstrings","title":"ThreeBodyTB.SCF.remove_scf_from_tbc","text":"function remove_scf_from_tbc(tbcK::tb_crys_kspace; smearing=0.01, e_den = missing)\n\nThis function takes a tbc_crys_kspace object that does not require scf and adjusts it  so that it does require scf, but gives the same energy and band structure.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.SCF.remove_scf_from_tbc-Tuple{tb_crys}","page":"Additional Docstrings","title":"ThreeBodyTB.SCF.remove_scf_from_tbc","text":"function remove_scf_from_tbc(tbc::tb_crys; smearing=0.01, grid = missing, e_den = missing)\n\nThis function takes a tbc_crys object that does not require scf and adjusts it  so that it does require scf, but gives the same energy and band structure.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.SCF.scf_energy-Tuple{crystal, Dict}","page":"Additional Docstrings","title":"ThreeBodyTB.SCF.scf_energy","text":"function scf_energy(c::crystal, database::Dict; smearing=0.01, grid = missing, conv_thr = 1e-5, iters = 75, mix = -1.0, mixing_mode=:pulay, verbose=true)\n\nRun scf calculation of c::crystal, using database of coefs. The main user version is scf_energy in ThreeBodyTB, which calls this one.\n\nsmearing is smearing energy in Ryd.\ngrid is k-point grid (gamma centered MP), will use default.\nconv_thr convergence threshold in Ryd.\niters maximum iterations for first attempt\nmix=-1.0 default is choose mixing for you. Otherwise, set between 0.0 and 1.0\nmixing_mode=:pulay default using Pulay mixing (DIIS). Any other input uses simple mixing.\nverbose=true verbosity level.\n\n\n\n\n\n","category":"method"},{"location":"every/#ThreeBodyTB.SCF.scf_energy-Tuple{tb_crys}","page":"Additional Docstrings","title":"ThreeBodyTB.SCF.scf_energy","text":"function scf_energy(tbc::tb_crys; smearing=0.01, grid = missing, e_den0 = missing, conv_thr = 1e-5, iters = 75, mix = -1.0, mixing_mode=:pulay, verbose=true)\n\n\n\n\n\n","category":"method"},{"location":"every/#Utilty","page":"Additional Docstrings","title":"Utilty","text":"","category":"section"},{"location":"every/","page":"Additional Docstrings","title":"Additional Docstrings","text":"Modules = [ThreeBodyTB.Utility]","category":"page"},{"location":"every/#ThreeBodyTB.Utility","page":"Additional Docstrings","title":"ThreeBodyTB.Utility","text":"module Utility\n\nSome useful functions, mostly for converting stuff and loading files.\n\n\n\n\n\n","category":"module"},{"location":"core/#User-Functions","page":"Functions","title":"User Functions","text":"","category":"section"},{"location":"core/","page":"Functions","title":"Functions","text":"All of these functions are exported from ThreeBodyTB for your convenience.","category":"page"},{"location":"core/#Crystal-/-Energy","page":"Functions","title":"Crystal / Energy","text":"","category":"section"},{"location":"core/","page":"Functions","title":"Functions","text":"makecrys\nscf_energy\nscf_energy_force_stress\nrelax_structure\nread_tb_crys\nwrite_tb_crys","category":"page"},{"location":"core/#ThreeBodyTB.CrystalMod.makecrys","page":"Functions","title":"ThreeBodyTB.CrystalMod.makecrys","text":"makecrys(A,coords,types; units=missing)\n\nReturn a crystal object from 3×3 lattice, nat × 3 coords in crystal units, and nat element strings.\n\nWill use units set by set_units, with default to Ang. Can override with units.\n\nNote: also export-ed directly from ThreeBodyTB for convenience\n\njulia> makecrys([10.0 0 0; 0 10.0 0; 0 0 10.0], [0.0 0.0 0.0], [\"H\"])\nA1=     10.00000  0.00000  0.00000\nA2=     0.00000  10.00000  0.00000\nA3=     0.00000  0.00000  10.00000\n\nH    0.00000  0.00000  0.00000\n\n\n\n\n\nmakecrys(filename::String)\n\nRead filename, return crystal object. File can be POSCAR, or simple quantum espresso inputfile\n\nThe entire file can be in the string instead of the filename. The code decides which is which by looking for newlines\"\n\n\n\n\n\nmakecrys(lines::Array{String,1})\n\nRead string array, return crystal object. string array can be POSCAR, or simple quantum espresso inputfile\n\n\n\n\n\n","category":"function"},{"location":"core/#ThreeBodyTB.scf_energy","page":"Functions","title":"ThreeBodyTB.scf_energy","text":"scf_energy(c::crystal)\n\nCalculate energy, force, and stress for a crystal. Does self-consistent-field (SCF) calculation if using self-consistent electrostatics.\n\nreturns energy, tight-binding-crystal-object, error-flag\n\nArguments\n\nc::crystal: the structure to calculate on. Only required argument.\ndatabase=missing: Source of coeficients. Will be loaded from pre-fit coefficients if missing.\nsmearing=0.01: Gaussian smearing temperature, in Ryd. Usually can leave as default.\ngrid=missing: k-point grid, e.g. [10,10,10], default chosen automatically\nconv_thr = 1e-5: SCF convergence threshold (Ryd).\niter = 75: number of iterations before switch to more conservative settings.\nmix = -1.0: initial mixing. -1.0 means use default mixing. Will automagically adjust mixing if SCF is failing to converge.\nmixing_mode =:pulay: default is Pulay mixing (DIIS). Other option is :simple, for simple linear mixing of old and new electron-density. Will automatically switch to simple if Pulay fails.\n\n\n\n\n\nscf_energy(d::dftout)\n\nSCF energy using crystal structure from DFT object.\n\n\n\n\n\nscf_energy(tbc::tbc_crys)\n\nSCF energy using crystal structure from TBC object.\n\n\n\n\n\n","category":"function"},{"location":"core/#ThreeBodyTB.scf_energy_force_stress","page":"Functions","title":"ThreeBodyTB.scf_energy_force_stress","text":"scf_energy_force_stress(c::crystal; database = missing, smearing = 0.01, grid = missing)\n\nCalculate energy, force, and stress for a crystal.\n\nreturn energy, force, stress, tight_binding_crystal_object\n\nArguments\n\nc::crystal: the structure to calculate on. Only required argument.\ndatabase=missing: Source of coeficients. Will be loaded from pre-fit coefficients if missing.\nsmearing=0.01: Gaussian smearing temperature, in Ryd. Usually can leave as default.\ngrid=missing: k-point grid, e.g. [10,10,10], default chosen automatically\n\n\n\n\n\nscf_energy_force_stress(tbc::tb_crys; database = missing, smearing = 0.01, grid = missing)\n\nCalculate energy, force, and stress for a tight binding crystal object. This allows the calculation to run without re-doing the SCF calculation. Assumes SCF already done!\n\nreturns energy, force, stress, tightbindingcrystal_object\n\n\n\n\n\n","category":"function"},{"location":"core/#ThreeBodyTB.relax_structure","page":"Functions","title":"ThreeBodyTB.relax_structure","text":"relax_structure(c::crystal; mode=\"vc-relax\")\n\nFind the lowest energy atomic configuration of crystal c.\n\nArguments\n\nc::crystal: the structure to relax, only required argument\nmode=\"vc-relax\": Default (variable-cell relax) will relax structure and cell, anything else will relax structure only.\ndatabase=missing: coefficent database, default is to use the pre-fit pbesol database\nsmearing=0.01: smearing temperature (ryd), default = 0.01\ngrid=missing: k-point grid, e.g. [10,10,10], default chosen automatically\nnsteps=100: maximum iterations\nupdate_grid=true: update automatic k-point grid during relaxation\nconv_thr = 2e-3: Convergence threshold for gradient\nenergy_conv_thr = 2e-4: Convergence threshold for energy in Ryd\n\n\n\n\n\n","category":"function"},{"location":"core/#ThreeBodyTB.TB.read_tb_crys","page":"Functions","title":"ThreeBodyTB.TB.read_tb_crys","text":"function read_tb_crys(filename, tbc::tb_crys)\n\nReads and returns from filename a tb_crys object. See write_tb_crys\n\nIf cannot find \"filename\", will look for \"filename.xml\", \"filename.gz\", \"filename.xml.gz\"\n\nCan read gzipped files directly.\n\n\n\n\n\n","category":"function"},{"location":"core/#ThreeBodyTB.TB.write_tb_crys","page":"Functions","title":"ThreeBodyTB.TB.write_tb_crys","text":"function write_tb_crys(filename, tbc::tb_crys)\n\nWrites to filename a tb_crys object, using xml formatting. See read_tb_crys\n\n\n\n\n\n","category":"function"},{"location":"core/#Plotting","page":"Functions","title":"Plotting","text":"","category":"section"},{"location":"core/","page":"Functions","title":"Functions","text":"plot_bandstr\ndos\nplot_compare_dft\nplot_compare_tb\nband_summary","category":"page"},{"location":"core/#ThreeBodyTB.BandStruct.plot_bandstr","page":"Functions","title":"ThreeBodyTB.BandStruct.plot_bandstr","text":"function plot_bandstr(h::tb_crys; kpath, names = missing, proj_types=missing, proj_orbs = missing, proj_nums=missing)\n\nPlot the band structure of a tb_crys object. Can also perform a projected band structure if you specify at least one of proj_types, proj_orbs, proj_nums.\n\nk-path specified by a kpath array and names.\n\nMust do scf calculation before plotting.\n\nArguments\n\nh::tb_crys - The tight-biding object we want to plot bands from. Only required argument.\nkpath=[0.5 0 0 ; 0 0 0; 0.5 0.5 0.5; 0 0.5 0.5; 0 0 0 ;0 0 0.5] - nk × 3 array k-point path (high symmetry points).\nnpts=30, - number of points between high-symmetry k-points.\nnames=missing - nk string array. Names of the high-symmetry k-points \nproj_types=missing - types to project onto. Either proj_types=\"H\" or proj_types=[\"H\", \"O\"] are valid.\nproj_orbs=missing - orbitals to project onto. either proj_orbs=:s or proj_orbs=[:s, :p].\nproj_nums=missing - atom numbers to project onto. Either proj_nums=1 or proj_nums=[1, 2]\nefermi=missing - allows you to specify fermi energy. Default is to take from h\ncolor=\"blue\" - specify line color\nMarkerSize=missing\" - specify markersize\nyrange=missing\" - specify y-range. e.g. yrange=[-0.7, 0.3]\nplot_hk=false - plot things besides the normal band structure. Can be one of :Seig, :Heig, :Hreal, :Himag, :Sreal, :Simag to plot H or S eigvals or components. Primarily for debugging.\nalign=\"vbm\" - default or \"valence\" is to align valence band max to zero energy. Can also be \"min\", which aligns on the minimum eigenvalue, or \"fermi\" or \"ef\", which align on the Fermi level, \nclear_pervious=true - clears the plot before adding new stuff.\ndo_display=true - display the plot. If false, can be used with display-less nodes. You can still use savefig from Plots to produce saved images.\n\n\n\n\n\nfunction plot_bandstr(h::tb)\n\nPlots using tb\n\n\n\n\n\n","category":"function"},{"location":"core/#ThreeBodyTB.DOS.dos","page":"Functions","title":"ThreeBodyTB.DOS.dos","text":"function dos(tbc::tb_crys; grid=missing, npts=missing, proj_type=missing, do_display=true)\n\nDOS, using tetrahedral integration\n\ngrid is the k-point grid. Defaults to 1.6 times the default grid for energy integration.\nnpts is number of energies\nproj_type can be \"none\", \"atomic\", or \"orbital\". Defaults to atomic if more than one atom type.\ndo_display=false will suppress plotting\n\nreturn energies, dos, projected_dos, pdos_names\n\n\n\n\n\n","category":"function"},{"location":"core/#ThreeBodyTB.BandStruct.plot_compare_dft","page":"Functions","title":"ThreeBodyTB.BandStruct.plot_compare_dft","text":"function plot_compare_dft(tbc, bs; tbc2=missing)\n\nPlots a band structure comparison between a tight-binding crystal object (tb_crys) and a band structure directly from dft (either a dftout or bs object). \n\nThe k-points are fixed by the bs object.\n\ntbc2 is an optional second tbc_crys.\n\n\n\n\n\n","category":"function"},{"location":"core/#ThreeBodyTB.BandStruct.plot_compare_tb","page":"Functions","title":"ThreeBodyTB.BandStruct.plot_compare_tb","text":"function plot_compare_tb(h1::tb_crys, h2::tb_crys; h3=missing)\n\nPlot a comparison between different tight binding objects h1, h2, and optionally h3. Options similar to plot_bandstr but more limited.\n\n\n\n\n\nfunction plot_compare_tb(h1::tb, h2::tb; h3=missing)\n\n\n\n\n\n","category":"function"},{"location":"core/#ThreeBodyTB.BandStruct.band_summary","page":"Functions","title":"ThreeBodyTB.BandStruct.band_summary","text":"function band_summary(tbc, kgrid, fermi=missing)\n\nProduces summary of band structure. See below functions for more specific versions of function that automatically generate the k-points.\n\nNote: gaps are not well-defined for non-magnetic systems with odd numbers of electrons, as they are required to be metals.\n\nReturns direct_gap, indirect_gap, gaptype, bandwidth\n\n-direct_gap: minimum gap at one k-point between nominally filled and empty bands. Can be non-zero in metals.   -indirect_gap: LUMO - HOMO. Can be negative if material has a direct gap everywhere, but the conduction band at some k-point is below the valence band at a different k-point. Physically these are indirect gap semimetals.   -gaptype : is :metal for all metals, :direct or :indirect for insulators. -bandwidth : HOMO - minimumbandenergy. Included semicore states if they are in the TB calculation.\n\n\n\n\n\nfunction band_summary(tbc::tb_crys; kgrid=missing, kpts=missing)\n\nWill automatically generate standard k-grid by default.\n\n\n\n\n\nfunction band_summary(tbc::tb_crys_kspace)\n\nWill use internal k-points by default.\n\n\n\n\n\n","category":"function"},{"location":"core/#Utility","page":"Functions","title":"Utility","text":"","category":"section"},{"location":"core/","page":"Functions","title":"Functions","text":"set_units\nHk\ncalc_bands\ncalc_tb_fast","category":"page"},{"location":"core/#ThreeBodyTB.set_units","page":"Functions","title":"ThreeBodyTB.set_units","text":"function set_units(;energy=missing, length=missing, both=missing)\n\nSet global units for energy/length. Run with no arguments to check/return current units.\n\nDefault units are \"eV\" and \"Angstrom\" (or \"Å\" or \"Ang\" ).\nChoose atomic units by setting energy=\"Ryd\" and length=\"Bohr\".\nSet both at the same time with both=\"atomic\" or both=\"eVAng\"\nInternally, all units are atomic. Only main public facing functions actually change units.\n\n\n\n\n\n","category":"function"},{"location":"core/#ThreeBodyTB.TB.Hk","page":"Functions","title":"ThreeBodyTB.TB.Hk","text":"function Hk(h::tbcryskspace, kpoint)\n\nCalculate band structure at a k-point from a tb_crys_kspace object. Note, can only return precalculated k-points. Need real-space version to get arbitrary k-points.\n\n#Returns\n\nvect - Eigenvectors numwan × numwan complex matrix at kpoint\nvals - Eigenvalues (num_wan)\nhk - Hamiltonian at kpoint\nsk - Overlap matrix at kpoint\nvals0 - <vect | Hk0 | vect> where Hk0 is the non-scf part of the Hamiltonian.\n\n#Arguments\n\nh::tb_crys_kspace - tbcryskspace object\nkpoint - e.g. [0.0,0.0,0.0]\nscf=missing - default is to take SCF from h.\n\n\n\n\n\nfunction Hk(h::tb_k, kpoint)\n\nCalculate band structure at a k-point from tb_k. Must be pre-calculated k-point.\n\n\n\n\n\nfunction Hk(hk,sk, h::tb, kpoint)\n\nHk function with pre-allocated memory hk, sk\n\n\n\n\n\nfunction Hk(h::tb, kpoint)\n\nCalculate band structure at a k-point from tb\n\n\n\n\n\nfunction Hk(h::tb_crys, kpoint)\n\nCalculate band structure at a k-point from tb_crys\n\n\n\n\n\n","category":"function"},{"location":"core/#ThreeBodyTB.TB.calc_bands","page":"Functions","title":"ThreeBodyTB.TB.calc_bands","text":"function calc_bands(tbc::tb_crys, kpoints::Array{Float64,2})\n\nCalculate bandstructure for k-points from k-point array. Returns eigenvalues.\n\nArguments\n\ntbc::tb_crys - The tight binding object\nkpoints::Array{Float64,2} - k-point array. e.g. [0.0 0.0 0.0; 0.0 0.0 0.1]\n\n\n\n\n\nfunction calc_bands(h, kpoints::Array{Float64,2})\n\nCalculate bandstructure for k-points from k-point array. h is a tb or tb_k object.\n\n\n\n\n\n","category":"function"},{"location":"core/#ThreeBodyTB.CalcTB.calc_tb_fast","page":"Functions","title":"ThreeBodyTB.CalcTB.calc_tb_fast","text":"calc_tb_fast(crys::crystal; database=missing, use_threebody=true, use_threebody_onsite=true)\n\nConstruct tb_crys from crystal stucture, but does not solve. This is usually called internally by functions like scf_energy, but you can use it directly if you want. Until you do a SCF energy calculation, the electron density and Fermi level will be wrong.\n\nArguments\n\ncrys::crystal - Required crystal structure\ndatabase=missing - Source of coefficients. Will load from default source if not specified.\nuse_threebody=true - Use three-body off-site interactions. Only turn off for testing purposes.\nuse_threebody_onsite=true - Use three-body on-site interactions. Only turn off for testing purposes.\nverbose=true - set to false for less output.\nvar_type=missing - variable type of tb_crys. Default is Float64.\n\n\n\n\n\n","category":"function"},{"location":"compile/#Compiling-/-Python","page":"Compile/Python","title":"Compiling / Python","text":"","category":"section"},{"location":"compile/#Compiling","page":"Compile/Python","title":"Compiling","text":"","category":"section"},{"location":"compile/","page":"Compile/Python","title":"Compile/Python","text":"Julia normally makes heavy use of just-in-time (jit) compilation to compile efficient versions of functions for any given input types. This has a side effect that the second time you run a given function with certain variable types is much faster than the first time, because the efficient compiled machine code is cached.","category":"page"},{"location":"compile/","page":"Compile/Python","title":"Compile/Python","text":"It is possible to store a system image file that contains compiled versions of functions from a Julia package, using the PackageCompiler package. This will greatly reduce the time to load and run the first instance of the already compiled functions.","category":"page"},{"location":"compile/","page":"Compile/Python","title":"Compile/Python","text":"To help automate this process, you can use the compile() function. It is recommended that you precompile Plots at the same time.","category":"page"},{"location":"compile/","page":"Compile/Python","title":"Compile/Python","text":"using ThreeBodyTB; using Plots; ThreeBodyTB.compile()","category":"page"},{"location":"compile/","page":"Compile/Python","title":"Compile/Python","text":"This will run the examples in order to compile the appropriate functions into the memory, and then create a file called sys_threebodytb.so in ~/.julia/sysimages/. To load the sysimage, run Julia as ","category":"page"},{"location":"compile/","page":"Compile/Python","title":"Compile/Python","text":"julia –sysimage ~/.julia/sysimages/sys_threebodytb.so","category":"page"},{"location":"compile/","page":"Compile/Python","title":"Compile/Python","text":"Note that the compilation takes several minutes and significant disk space. If you want to update the code, you will have to delete and remake the sys image.","category":"page"},{"location":"compile/#Python","page":"Compile/Python","title":"Python","text":"","category":"section"},{"location":"compile/","page":"Compile/Python","title":"Compile/Python","text":"While running ThreeBodyTB using Julia is the easiest option, I understand that many users have existing codes in Python. Therefore, I have created a separate github package in python, ThreeBodyTB_python, that hosts a wrapper that allows the user to call my Julia functions like they were in python.","category":"page"},{"location":"compile/","page":"Compile/Python","title":"Compile/Python","text":"This works by using the PyJulia interface. The wrapper will, if necessary, a) download & install Julia b) download & install ThreeBodyTB.jl, and c) create a system image for fast loading in python.","category":"page"},{"location":"theindex/#Index","page":"-","title":"Index","text":"","category":"section"},{"location":"theindex/","page":"-","title":"-","text":"","category":"page"},{"location":"structs/#Core-User-Data-(structs)","page":"Structs","title":"Core User Data (structs)","text":"","category":"section"},{"location":"structs/","page":"Structs","title":"Structs","text":"crystal\ntb\ntb_crys","category":"page"},{"location":"structs/#ThreeBodyTB.CrystalMod.crystal","page":"Structs","title":"ThreeBodyTB.CrystalMod.crystal","text":"mutable struct crystal{T}\n\nHolds basic crystal structure information, type T. Use makecrys to easily construct.\n\nNote: you can create supercells like\n\njulia> c = makecrys([5.0 0 0; 0 5.0 0; 0 0 5.0], [0.0 0.0 0.0], [\"H\"])\nA1=     5.00000  0.00000  0.00000\nA2=     0.00000  5.00000  0.00000\nA3=     0.00000  0.00000  5.00000\n\nH    0.00000  0.00000  0.00000\n\n\njulia> c*[2,2,2]\nA1=     10.00000  0.00000  0.00000\nA2=     0.00000  10.00000  0.00000\nA3=     0.00000  0.00000  10.00000\n\nH    0.00000  0.00000  0.00000\nH    0.00000  0.00000  0.50000\nH    0.00000  0.50000  0.00000\nH    0.00000  0.50000  0.50000\nH    0.50000  0.00000  0.00000\nH    0.50000  0.00000  0.50000\nH    0.50000  0.50000  0.00000\nH    0.50000  0.50000  0.50000\n\nHolds\n\nA::Array{T,2} 3 × 3 lattice vectors, Bohr (atomic units) internally.\ncoords::Array{T,2} num_atoms × 3  atomic positions, fractional units.\ntypes::Array{String,1} atomic names, like \"H\" or \"Zn\".\ntypes::Array{Symbol,1} atomic names, but julia Symbols like :H or :Zn, for nominally faster internal evaluation.\nnat::Int64 number of atoms.\n\n\n\n\n\n","category":"type"},{"location":"structs/#ThreeBodyTB.TB.tb","page":"Structs","title":"ThreeBodyTB.TB.tb","text":"mutable struct tb{T}\n\nHolds key tight-binding information in real-space. Like _hr.dat file from Wannier90. Also part of the tb_crys object.\n\nHolds\n\nH::Array{Complex{T},3} Hamiltonian. nw×nw×nr\nind_array::Array{Int64,3} nr×3 , holds the r-space supercells of the TB object.\nr_dict::Dict keys are three Ints like [0,0,0], returns the corresponding ind_array index.\nnwan::Int Number of orbitals (generalized wannier functions).\nnr::Int64 number of R-space supercells.\nnonorth::Bool :  true if non-orthogonal. Almost always true in this code.\nS::Array{Complex{T},3} : Overlap matrix, organized like H\nscf::Bool equal to true if requires self-consistency (usually true for fit tb, false for direct from DFT)\nh1::Array{T,2} Has the term determined by scf calculations, if calculated already.\n\n\n\n\n\n","category":"type"},{"location":"structs/#ThreeBodyTB.TB.tb_crys","page":"Structs","title":"ThreeBodyTB.TB.tb_crys","text":"mutable struct tb_crys{T}\n\nMain tight-binding object, holds the tight-binding model tb and information about the crystal\n\nHolds\n\ntb::tb Has the key tb info (see above)\ncrys::crystal Has the crystal structure\nnelec::Float64 Number of electrons\ndftenergy::Float64 DFT energy for reference, only for fit to DFT cases.\nscf::Bool  true if requires self-consistency.\ngamma::Array{T, 2} has the Ewald calculation results, needed for self-consistency.\neden::Array{Float64,1} electron density, by orbital, if calculated by self-consistency.\nwithin_fit::Bool is true if model is passes tests of being within the fitting parameter space, false for extrapolation\nenergy::Float64 energy in Ryd, if calculated.\nefermi::Float64 Fermi energy in Ryd, if calculated.\n\n\n\n\n\n","category":"type"},{"location":"ug_run/#Running-tight-binding-calculations","page":"Running Calculations","title":"Running tight-binding calculations","text":"","category":"section"},{"location":"ug_run/","page":"Running Calculations","title":"Running Calculations","text":"How to run tight-binding calculations using the pre-fit tight-binding coefficients. Note, only elemental and binary systems are currently supported.","category":"page"},{"location":"ug_run/","page":"Running Calculations","title":"Running Calculations","text":"note: Note\nRunning a julia function for the first time will compile the function. Future runs will be much faster.","category":"page"},{"location":"ug_run/#**Create-a-crystal-object**","page":"Running Calculations","title":"Create a crystal object","text":"","category":"section"},{"location":"ug_run/","page":"Running Calculations","title":"Running Calculations","text":"Use makecrys to create a crystal from lattice vectors, atomic positions, and atom types:","category":"page"},{"location":"ug_run/","page":"Running Calculations","title":"Running Calculations","text":"using ThreeBodyTB\nA = [2.1 2.1 0.0;2.1 0.0 2.1;0.0 2.1 2.1];\npos = [0.0 0.0 0.0];\ntypes =        [\"Al\"];\nfcc_al = makecrys(A, pos, types)","category":"page"},{"location":"ug_run/","page":"Running Calculations","title":"Running Calculations","text":"Current default units are Angstrom and eV. You can change the global units to atomic units with set_units(both=\"atomic\") if you prefer.","category":"page"},{"location":"ug_run/","page":"Running Calculations","title":"Running Calculations","text":"Alternatively, you can read the positions from a simple POSCAR or Quantum Espresso input file.","category":"page"},{"location":"ug_run/","page":"Running Calculations","title":"Running Calculations","text":"rbcl = makecrys(\"../src/POSCAR_rbcl\")","category":"page"},{"location":"ug_run/#**Do-a-self-consistent-calculation.**","page":"Running Calculations","title":"Do a self-consistent calculation.","text":"","category":"section"},{"location":"ug_run/","page":"Running Calculations","title":"Running Calculations","text":"Gets the energy and charge density with scf_energy:","category":"page"},{"location":"ug_run/","page":"Running Calculations","title":"Running Calculations","text":"alp = makecrys(\"../src/POSCAR_alp\")\nenergy, tbc_alp = scf_energy(alp); \nprintln(\"The energy is $energy eV\")","category":"page"},{"location":"ug_run/","page":"Running Calculations","title":"Running Calculations","text":"This returns the (non-magnetic) atomization energy, and a tight-binding object with the TB matrix elements and SCF electron density calculated for post-processing.","category":"page"},{"location":"ug_run/#**Plot-the-band-structure.**","page":"Running Calculations","title":"Plot the band structure.","text":"","category":"section"},{"location":"ug_run/","page":"Running Calculations","title":"Running Calculations","text":"Using the tb_crys tight-binding object tbc_alp from above. Note: SCF must be done first.","category":"page"},{"location":"ug_run/","page":"Running Calculations","title":"Running Calculations","text":"using Plots #hide\ngr() #hide\nENV[\"GKSwstype\"] = \"100\" #hide\nplot_bandstr(tbc_alp, do_display=false); \nsavefig(\"alp.png\"); #hide","category":"page"},{"location":"ug_run/","page":"Running Calculations","title":"Running Calculations","text":"(Image: AlP plot)","category":"page"},{"location":"ug_run/","page":"Running Calculations","title":"Running Calculations","text":"Use do_display=true (the default) to produce an interactive plot. Here do_display is set to false because we are saving a static figure with savefig for the docs.","category":"page"},{"location":"ug_run/","page":"Running Calculations","title":"Running Calculations","text":"The default plot_bandstr just picks some random kpoints, but you can add your own kpath. We can also project onto the s orbital of Al.","category":"page"},{"location":"ug_run/","page":"Running Calculations","title":"Running Calculations","text":"kpath=[0.0 0.0 0.0; 0.5 0.5 0.5; 0.0 0.5 0.5];\nknames=[\"Γ\", \"X\", \"V\"];\nplot_bandstr(tbc_alp, kpath=kpath, names=knames, npts=100, proj_orbs=[:s], proj_types=[\"Al\"], do_display=false);\nsavefig(\"alp2.png\"); #hide","category":"page"},{"location":"ug_run/","page":"Running Calculations","title":"Running Calculations","text":"(Image: AlP plot 2)","category":"page"},{"location":"ug_run/","page":"Running Calculations","title":"Running Calculations","text":"You can also plot the DOS using dos","category":"page"},{"location":"ug_run/","page":"Running Calculations","title":"Running Calculations","text":"dos(tbc_alp, do_display=false);\nsavefig(\"alp_dos.png\"); #hide","category":"page"},{"location":"ug_run/","page":"Running Calculations","title":"Running Calculations","text":"(Image: AlP DOS)","category":"page"},{"location":"ug_run/","page":"Running Calculations","title":"Running Calculations","text":"Project onto orbitals instead with proj_type=:orbs","category":"page"},{"location":"ug_run/#**Calculate-force-/-stress**","page":"Running Calculations","title":"Calculate force / stress","text":"","category":"section"},{"location":"ug_run/","page":"Running Calculations","title":"Running Calculations","text":"With scf_energy_force_stress","category":"page"},{"location":"ug_run/","page":"Running Calculations","title":"Running Calculations","text":"energy, force, stress, tbc = scf_energy_force_stress(tbc_alp);\n\nprintln(\"energy $energy\")\nprintln()\nprintln(\"Forces\")\nshow(stdout, \"text/plain\", force)\nprintln()\nprintln(\"Stress\")\nshow(stdout, \"text/plain\", stress)\nnothing #hide","category":"page"},{"location":"ug_run/","page":"Running Calculations","title":"Running Calculations","text":"Can also be called directly on a new crystal structure instead of a tb_crys object.","category":"page"},{"location":"ug_run/#**Relax-structure**","page":"Running Calculations","title":"Relax structure","text":"","category":"section"},{"location":"ug_run/","page":"Running Calculations","title":"Running Calculations","text":"Using relax_structure","category":"page"},{"location":"ug_run/","page":"Running Calculations","title":"Running Calculations","text":"crys_new, tbc_updated, energy, force, stress = relax_structure(alp);\n\nprintln(\"Energy new $energy\")\nprintln()\nprintln(\"Force\")\nshow(stdout, \"text/plain\", force)\nprintln()\nprintln(\"Stress\")\nshow(stdout, \"text/plain\", stress)\nnothing #hide","category":"page"},{"location":"ug_run/","page":"Running Calculations","title":"Running Calculations","text":"Energy is lower, stress is near zero, forces are zero by symmetry in Zinc Blende structure.","category":"page"},{"location":"ug_run/","page":"Running Calculations","title":"Running Calculations","text":"Force/Stress defaults are eV/Ang and eV/Ang^3.","category":"page"},{"location":"#ThreeBodyTB.jl-Documentation","page":"Home","title":"ThreeBodyTB.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A three-body tight binding program written in Julia","category":"page"},{"location":"","page":"Home","title":"Home","text":"Primary Author: Kevin F. Garrity, NIST","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nThis package is currently under development, but basic functionality should work. A manuscript is under preparation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ThreeBodyTB.jl is a package for tight-binding, written in Julia.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Run tight-binding calculations with near DFT level accuracy (PBEsol).\nGet results in seconds based on pre-fit parameters from across periodic table.\nCalculate band structures and total energies.\nGet forces, stresses, and relax structures.\nParameters based on two- and three-body interactions.\nIncludes self-consistent treatment of long-range Coulomb interaction.\nPlotting based on interface of Plots.jl","category":"page"},{"location":"#User's-guide","page":"Home","title":"User's guide","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"ug_run.md\", \"ug_fit.md\"]\nDepth = 2","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"ug_fit/#Fitting-tight-binding-coefficients-from-Quantum-Espresso.","page":"Fit Coefficients","title":"Fitting tight-binding coefficients from Quantum Espresso.","text":"","category":"section"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"ThreeBodyTB has a set of pre-fit coefficients that are sufficient for running elemental or binary systems without doing your own fitting. If you still want to do the fitting yourself, read on...","category":"page"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"Currently, ThreeBodyTB is set up to fit coefficients from Quantum Espresso (QE) DFT calculations from pw.x using the projwfc.x code to get atomic-wavefunction-projected band structures.","category":"page"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"It may be easiest to consider the fitting example in the examples/ folder while reading this.","category":"page"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"A brief overview of the steps:","category":"page"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"Tell ThreeBody.jl where you QE code is, and optionally pseudopotentials, etc.\nRun self-consistent-field (SCF) non-spin-polarized DFT total energy calculations.\nRun ThreeBodyTB.AtomicProj.projwfc_workf to get k-space tight-binding models for each SCF calculation. This runs a non-SCF DFT calculation with pw.x and atomic projections with projwfc.x, and then calculates the TB model.\nRun the fitting code ThreeBodyTB.FitTB.do_fitting_recursive","category":"page"},{"location":"ug_fit/#.-Preliminaries","page":"Fit Coefficients","title":"0. Preliminaries","text":"","category":"section"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"You need to install Quantum Espresso (make pw; make pp) and let the code know where the bin/ directory is. For example, set_bin_dirs(qe=\"/home/kfg/codes/q-e-qe-6.5/bin/\").  You also need to let it know about any mpi commands you may need to run in parallel unless you use mpirun. set_bin_dirs(qe=\"/home/kfg/codes/q-e-qe-6.5/bin/\", mpi=\"mpirun -np \"), where you must insert your appropriate command.","category":"page"},{"location":"ug_fit/#Using-different-pseudopotential-or-convergence-settings.","page":"Fit Coefficients","title":"Using different pseudopotential or convergence settings.","text":"","category":"section"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"By default, the code is set up for the slightly modified GBRV pseudopotential set available in this distribution under pseudo/gbrv_pbesol/. The default template QE input files are in template_inputs/. You can change those directories as well with set_bin_dirs(pseudodir=\"mypsp/\", templatedir=\"mytemp/\")","category":"page"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"If you do change those, you will also have to edit ThreeBodyTB.Atomdata:atoms. In particular, you need to perform some non-spin-polarized isolated atom calculations to get atomic data. From those, you need the total energy, the number of semicore states, the types of valence orbitals, the energies of valence orbitals, and the U values. You can get U from calculations with variable numbers of electrons.","category":"page"},{"location":"ug_fit/#.-Do-DFT-calculations.","page":"Fit Coefficients","title":"1. Do DFT calculations.","text":"","category":"section"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"You need SCF DFT data to fit to. Create crystal structures with makecrys and then run dft calculations. For example:","category":"page"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"c = makecrys([10 0 0; 0 10 0; 0 0 10], [0 0 0], [\"H\"]);\ndft = ThreeBodyTB.DFT.runSCF(c, directory=\"dirname\", tmpdir=\"dirname\",nprocs=8 )","category":"page"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"You can look in code_for_dataset_gen/Prototypes.jl and reference_structures/ for examples of how to create a database of example structures.","category":"page"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"You can load dft variables from the \"prefix.save/data-file-schema.xml\" output file as dft = [ThreeBodyTB.QE.loadXML](@ref)(\"prefix.save\"). You will need the charge density in the next step to run the non-SCF calculation, but after that you don't need the wavefunctions or charge density from either the DFT or NSCF run.","category":"page"},{"location":"ug_fit/#.-Create-the-tight-binding-Hamiltonian-for-each-DFT-calculation","page":"Fit Coefficients","title":"2. Create the tight-binding Hamiltonian for each DFT calculation","text":"","category":"section"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"The function ThreeBodyTB.AtomicProj.projwfc_workf will perform all of the calculations to create a projected tight-binding Hamiltonian from a DFT calculation (workf stands for workflow). The basic steps it will perform are:","category":"page"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"Run a non-SCF calculation with more bands, so that every atomic orbital can project onto bands.\nRun projwfc.x to get the atomic wavefunction projected band structure (the file prefix.save/atomic_proj.xml).\nGet the projected Hamiltonian in k-space.\n(Optional) Fourier transform to get the Hamiltonian in r-space","category":"page"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"The optional Fourier transform only works if the k-grid from the NSCF is a regular gamma centered MP grid without symmetry. However, this step isn't necessary for the main fitting procedure. You can use the Hamiltonian in k-space directly, saving computing time.","category":"page"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"A typical call is","category":"page"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"tbc, tbck, projection_warning = ThreeBodyTB.AtomicProj.projwfc_workf(\n     dft,\n     directory=\"dirname\",\n     nprocs=8,\n     only_kspace=true)","category":"page"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"tbck is the important return, which is the tight binding Hamiltonian in k-space tb_crys_kspace. projection_warning will warn you if the quality of the projection is detected to be low. This can be caused by atoms that are too close together or not including enough empty bands to guarantee that all of the atomic wavefunctions can project onto some states.","category":"page"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"In order to fit a SCF model, it is necessary to subtract the self-consistent part from the TB Hamiltonian with ThreeBodyTB.SCF.remove_scf_from_tbc:","category":"page"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"tbck_scf = ThreeBodyTB.SCF.remove_scf_from_tbc(tbck);","category":"page"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"You can read/write either tbck or tbck_scf with ThreeBodyTB.TB.read_tb_crys_kspace or ThreeBodyTB.TB.write_tb_crys_kspace","category":"page"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"If only_kspace=false you will also get the real-space tbc output, which is similar to the \"prefix_hr.dat\" from Wannier90, and you can also use remove_scf_from_tbc on that struct and use it in the fitting. The read/write functions are ThreeBodyTB.read_tb_crys and ThreeBodyTB.write_tb_crys. These files can also be used to interpolate band structures or DOS to arbitrary k-points like a Wannier Hamiltonian, while the k-space versions are limited to fixed k-point grids.","category":"page"},{"location":"ug_fit/#.-Do-actual-fitting","page":"Fit Coefficients","title":"3. Do actual fitting","text":"","category":"section"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"An example command to actually do the fitting is","category":"page"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"database = ThreeBodyTB.FitTB.do_fitting_recursive(\n\t tbck_scf_list,\n\t dft_list = dft_list,\n\t weights_list=weights_list,\n\t starting_dict=starting_dict,\n\t NLIM=50)","category":"page"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"Here, tbck_scf_list is an array of tbck_scf or tbc_scf variables (type TB.tb_crys_kspace), and dft_list is an array of dft variables (type DFToutMod.dftout). weights_list is an optional array of the real numbers with relative weights of the structures for the fitting. NLIM is the maximum number of k-points to use for each structure. Higher values will require more time to do the fitting.","category":"page"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"starting_dict is a dictionary of previously fit coefficients that are not included in the fitting and are kept frozen. For example, when fitting binaries, typically the elemental fitting coefficients are kept frozen to their elemental values.","category":"page"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"There are many other options to this function. ks_weight and rs_weight are the k-space and real-space weights for fitting of the tight-binding matrix elements. Default is to set both to zero and only fit eigenvalues/energies. energy_weight is the weight of the total energy, relative to the eigenvalues. Default is 20.0.  niters is the number of recursive iterations. lambda is a regularization parameter, default is 0.0 (no regularization). RW_PARAM is the weight of the fully empty eigenvalues relative to the filled ones. Default is 0.0 (no weight to high energy empty states, although there is some weight to states near the Fermi level).","category":"page"},{"location":"ug_fit/#.-Run-calculations-with-new-database","page":"Fit Coefficients","title":"4. Run calculations with new database","text":"","category":"section"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"The dictionary returned by the fitting function has coefficient objects (type ThreeBodyTB.CalcTB.coefs) in it, as well as a variable on whether the coefficients require self-consistency or not. For example, if we fit Al coefficients, there will be keys with (:Al, :Al), with the two-body interaction coefs, and (:Al, :Al, :Al) with the three body interactions, and a bool called \"SCF\".","category":"page"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"You can save the coefficients in xml files for use later with ThreeBodyTB.CalcTB.write_coefs(\"Al_2bdy.xml\", database[(:Al,Al)]) and read them with ThreeBodyTB.CalcTB.read_coefs(\"Al_2bdy.xml\")","category":"page"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"You can use the coefficients to run a calculation by using scf_energy(c; database = database), which will override the default database and use your database. The force/stress and relaxations similarly take database variables.","category":"page"},{"location":"ug_fit/","page":"Fit Coefficients","title":"Fit Coefficients","text":"There is also a way to manage a directory with coefficients in it. You have to setup your directory structure the same way as dats/pbesol/v1.2/. Then, you can also load coefficients as needed for crystal c stored in a directory using ThreeBodyTB.ManageDatabase.prepare_database(c; directory=\"dirname\") into the internal database cache, instead of loading from the default directory with pre-fit coefficients. Note, this will only work if the coefficients follow my naming conventions.","category":"page"}]
}
